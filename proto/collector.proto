syntax = "proto3";

package tapio.collector.v1;

option go_package = "github.com/yairfalse/tapio/pkg/grpc;grpc";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "proto/events.proto";

// CollectorService defines the streaming communication between
// collectors and the Tapio server, optimized for high-throughput
// event streaming with backpressure and resilience.
service CollectorService {
  // StreamEvents establishes a bidirectional streaming connection
  // for real-time event delivery with flow control
  rpc StreamEvents(stream StreamRequest) returns (stream StreamResponse);
  
  // SendEventBatch sends a batch of events in a single request
  // for scenarios where streaming is not required
  rpc SendEventBatch(EventBatchRequest) returns (EventBatchResponse);
  
  // RegisterCollector registers a collector with the server
  // and returns configuration and routing information
  rpc RegisterCollector(CollectorRegistration) returns (CollectorConfig);
  
  // Heartbeat maintains connection health and provides
  // real-time status updates
  rpc Heartbeat(stream HeartbeatRequest) returns (stream HeartbeatResponse);
  
  // GetServerInfo returns server capabilities and configuration
  rpc GetServerInfo(ServerInfoRequest) returns (ServerInfoResponse);
}

// StreamRequest contains events or control messages from collector to server
message StreamRequest {
  // Request sequence number for ordering and acknowledgment
  uint64 sequence = 1;
  
  // Collector identifier
  string collector_id = 2;
  
  // Request payload
  oneof payload {
    // Batch of events to process
    EventBatch events = 10;
    
    // Flow control message
    FlowControlMessage flow_control = 11;
    
    // Collector status update
    CollectorStatus status = 12;
    
    // Acknowledgment of received response
    AckMessage ack = 13;
  }
}

// StreamResponse contains responses and control messages from server to collector
message StreamResponse {
  // Response sequence number for ordering
  uint64 sequence = 1;
  
  // Timestamp when response was generated
  google.protobuf.Timestamp timestamp = 2;
  
  // Response payload
  oneof payload {
    // Acknowledgment of processed events
    EventAck event_ack = 10;
    
    // Flow control directive
    FlowControlDirective flow_control = 11;
    
    // Server status or configuration update
    ServerStatus server_status = 12;
    
    // Error information
    ErrorResponse error = 13;
  }
}

// EventBatch contains multiple events for efficient transmission
message EventBatch {
  // Batch identifier for tracking and deduplication
  string batch_id = 1;
  
  // When this batch was created
  google.protobuf.Timestamp created_at = 2;
  
  // Source collector information
  string collector_id = 3;
  string collector_type = 4;
  string node_id = 5;
  
  // Events in this batch
  repeated tapio.events.v1.UnifiedEvent events = 6;
  
  // Batch metadata
  BatchMetadata metadata = 7;
  
  // Compression used for this batch
  CompressionType compression = 8;
  
  // Quality metrics for this batch
  QualityMetrics quality = 9;
}

// BatchMetadata provides information about the batch
message BatchMetadata {
  // Total size of events before compression
  uint64 uncompressed_size = 1;
  
  // Size after compression
  uint64 compressed_size = 2;
  
  // Number of events in batch
  uint32 event_count = 3;
  
  // Time span covered by events in this batch
  google.protobuf.Duration time_span = 4;
  
  // Events that were dropped due to rate limiting
  uint32 dropped_events = 5;
  
  // Checksum for integrity verification
  string checksum = 6;
}

// QualityMetrics tracks the quality of collected events
message QualityMetrics {
  // Average confidence score (0.0 to 1.0)
  float avg_confidence = 1;
  
  // Percentage of events with full context
  float context_completeness = 2;
  
  // Processing latency statistics
  LatencyStats processing_latency = 3;
  
  // Collection latency statistics
  LatencyStats collection_latency = 4;
  
  // Error rates
  ErrorStats error_stats = 5;
}

// LatencyStats provides statistical information about latencies
message LatencyStats {
  google.protobuf.Duration min = 1;
  google.protobuf.Duration max = 2;
  google.protobuf.Duration avg = 3;
  google.protobuf.Duration p50 = 4;
  google.protobuf.Duration p95 = 5;
  google.protobuf.Duration p99 = 6;
}

// ErrorStats tracks error rates and types
message ErrorStats {
  uint32 total_errors = 1;
  uint32 validation_errors = 2;
  uint32 serialization_errors = 3;
  uint32 network_errors = 4;
  float error_rate = 5; // Errors per second
}

// FlowControlMessage allows collectors to request flow control changes
message FlowControlMessage {
  // Requested events per second
  uint32 requested_rate = 1;
  
  // Current buffer utilization (0.0 to 1.0)
  float buffer_utilization = 2;
  
  // Memory pressure indicator
  MemoryPressure memory_pressure = 3;
  
  // Reason for flow control request
  string reason = 4;
}

// FlowControlDirective instructs collectors on rate limiting
message FlowControlDirective {
  // Maximum events per second allowed
  uint32 max_events_per_second = 1;
  
  // Maximum batch size
  uint32 max_batch_size = 2;
  
  // Suggested batching interval
  google.protobuf.Duration batch_interval = 3;
  
  // Whether to enable compression
  bool enable_compression = 4;
  
  // Preferred compression algorithm
  CompressionType compression_type = 5;
  
  // Duration this directive is valid
  google.protobuf.Duration valid_duration = 6;
}

// EventAck acknowledges successful processing of events
message EventAck {
  // Batch ID that was processed
  string batch_id = 1;
  
  // Sequence number of acknowledged request
  uint64 request_sequence = 2;
  
  // Number of events successfully processed
  uint32 processed_count = 3;
  
  // Number of events that failed processing
  uint32 failed_count = 4;
  
  // List of event IDs that failed (if any)
  repeated string failed_event_ids = 5;
  
  // Processing time for this batch
  google.protobuf.Duration processing_time = 6;
  
  // Server timestamp when processing completed
  google.protobuf.Timestamp processed_at = 7;
}

// CollectorStatus reports collector health and statistics
message CollectorStatus {
  // Current state of the collector
  CollectorState state = 1;
  
  // Resource utilization
  ResourceUtilization resources = 2;
  
  // Collection statistics
  CollectionStats stats = 3;
  
  // Current configuration version
  string config_version = 4;
  
  // Uptime of the collector
  google.protobuf.Duration uptime = 5;
  
  // Last known issues or warnings
  repeated string warnings = 6;
}

// ServerStatus provides server health and load information
message ServerStatus {
  // Current server load (0.0 to 1.0)
  float load = 1;
  
  // Available capacity for new connections
  uint32 available_capacity = 2;
  
  // Current number of connected collectors
  uint32 connected_collectors = 3;
  
  // Server configuration version
  string config_version = 4;
  
  // Rate limiting information
  RateLimitInfo rate_limits = 5;
  
  // Regional routing information
  repeated RegionInfo regions = 6;
}

// ResourceUtilization tracks collector resource usage
message ResourceUtilization {
  // CPU usage percentage (0.0 to 1.0)
  float cpu_usage = 1;
  
  // Memory usage in bytes
  uint64 memory_bytes = 2;
  
  // Memory limit in bytes
  uint64 memory_limit = 3;
  
  // Network bandwidth usage
  NetworkUtilization network = 4;
  
  // Disk I/O statistics
  DiskUtilization disk = 5;
}

// NetworkUtilization tracks network resource usage
message NetworkUtilization {
  // Bytes per second sent
  uint64 bytes_sent_per_sec = 1;
  
  // Bytes per second received
  uint64 bytes_received_per_sec = 2;
  
  // Current number of connections
  uint32 connections = 3;
  
  // Network latency to server
  google.protobuf.Duration latency = 4;
}

// DiskUtilization tracks disk I/O usage
message DiskUtilization {
  // Reads per second
  uint64 reads_per_sec = 1;
  
  // Writes per second  
  uint64 writes_per_sec = 2;
  
  // Bytes read per second
  uint64 bytes_read_per_sec = 3;
  
  // Bytes written per second
  uint64 bytes_written_per_sec = 4;
}

// CollectionStats tracks collection performance metrics
message CollectionStats {
  // Total events collected since start
  uint64 total_events = 1;
  
  // Events per second (current rate)
  float events_per_second = 2;
  
  // Total bytes processed
  uint64 total_bytes = 3;
  
  // Bytes per second (current rate)
  float bytes_per_second = 4;
  
  // Number of batches sent
  uint64 batches_sent = 5;
  
  // Average batch size
  float avg_batch_size = 6;
  
  // Error counters
  ErrorCounters errors = 7;
}

// ErrorCounters tracks various types of errors
message ErrorCounters {
  uint64 collection_errors = 1;
  uint64 serialization_errors = 2;
  uint64 network_errors = 3;
  uint64 validation_errors = 4;
  uint64 rate_limit_errors = 5;
}

// EventBatchRequest for non-streaming batch sending
message EventBatchRequest {
  EventBatch batch = 1;
  bool require_ack = 2;
  google.protobuf.Duration timeout = 3;
}

// EventBatchResponse for non-streaming batch responses
message EventBatchResponse {
  bool success = 1;
  string message = 2;
  EventAck ack = 3;
  FlowControlDirective flow_control = 4;
}

// CollectorRegistration registers a collector with the server
message CollectorRegistration {
  // Unique collector identifier
  string collector_id = 1;
  
  // Type of collector (ebpf, k8s, systemd, etc.)
  string collector_type = 2;
  
  // Version of the collector software
  string version = 3;
  
  // Node information where collector is running
  NodeInfo node = 4;
  
  // Collector capabilities
  CollectorCapabilities capabilities = 5;
  
  // Requested configuration
  ConfigurationRequest config_request = 6;
}

// NodeInfo provides information about the node running the collector
message NodeInfo {
  string node_id = 1;
  string hostname = 2;
  string os = 3;
  string architecture = 4;
  string kernel_version = 5;
  string region = 6;
  string zone = 7;
  map<string, string> labels = 8;
}

// CollectorCapabilities describes what the collector can do
message CollectorCapabilities {
  // Maximum events per second this collector can handle
  uint32 max_events_per_second = 1;
  
  // Supported compression algorithms
  repeated CompressionType supported_compression = 2;
  
  // Supported event types
  repeated string supported_event_types = 3;
  
  // Whether collector supports streaming
  bool supports_streaming = 4;
  
  // Whether collector supports batching
  bool supports_batching = 5;
  
  // Maximum batch size supported
  uint32 max_batch_size = 6;
  
  // Buffer size in bytes
  uint64 buffer_size = 7;
}

// ConfigurationRequest specifies desired collector configuration
message ConfigurationRequest {
  // Preferred events per second
  uint32 preferred_rate = 1;
  
  // Preferred batch size
  uint32 preferred_batch_size = 2;
  
  // Preferred compression
  CompressionType preferred_compression = 3;
  
  // Event filtering rules requested
  repeated string event_filters = 4;
  
  // Quality settings
  QualitySettings quality = 5;
}

// QualitySettings configures quality requirements
message QualitySettings {
  // Minimum confidence threshold
  float min_confidence = 1;
  
  // Required context completeness
  float required_context = 2;
  
  // Maximum acceptable latency
  google.protobuf.Duration max_latency = 3;
}

// CollectorConfig provides configuration from server to collector
message CollectorConfig {
  // Assigned collector ID (may differ from requested)
  string collector_id = 1;
  
  // Configuration version
  string config_version = 2;
  
  // Flow control settings
  FlowControlDirective flow_control = 3;
  
  // Event routing configuration
  RoutingConfig routing = 4;
  
  // Quality requirements
  QualitySettings quality = 5;
  
  // Server endpoints for load balancing
  repeated ServerEndpoint endpoints = 6;
  
  // Heartbeat interval
  google.protobuf.Duration heartbeat_interval = 7;
  
  // Configuration TTL
  google.protobuf.Duration config_ttl = 8;
}

// RoutingConfig specifies how events should be routed
message RoutingConfig {
  // Default route for events
  string default_route = 1;
  
  // Event type specific routing
  map<string, string> type_routes = 2;
  
  // Priority routing for high-priority events
  string priority_route = 3;
  
  // Load balancing strategy
  LoadBalancingStrategy strategy = 4;
}

// ServerEndpoint provides server connection information
message ServerEndpoint {
  string address = 1;
  uint32 port = 2;
  bool tls_enabled = 3;
  string region = 4;
  uint32 weight = 5;
  HealthStatus health = 6;
}

// HeartbeatRequest maintains connection health
message HeartbeatRequest {
  string collector_id = 1;
  google.protobuf.Timestamp timestamp = 2;
  CollectorStatus status = 3;
  string config_version = 4;
}

// HeartbeatResponse provides heartbeat acknowledgment and updates
message HeartbeatResponse {
  google.protobuf.Timestamp timestamp = 1;
  ServerStatus server_status = 2;
  string config_version = 3;
  bool config_update_available = 4;
  FlowControlDirective flow_control = 5;
}

// ServerInfoRequest requests server information
message ServerInfoRequest {
  string client_version = 1;
  repeated string supported_features = 2;
}

// ServerInfoResponse provides server capabilities
message ServerInfoResponse {
  string server_version = 1;
  repeated string supported_features = 2;
  ServerCapabilities capabilities = 3;
  repeated CompressionType supported_compression = 4;
  RateLimitInfo rate_limits = 5;
}

// ServerCapabilities describes server features
message ServerCapabilities {
  uint64 max_events_per_second = 1;
  uint32 max_concurrent_collectors = 2;
  uint32 max_batch_size = 3;
  bool supports_streaming = 4;
  bool supports_compression = 5;
  bool supports_load_balancing = 6;
}

// RateLimitInfo provides rate limiting information
message RateLimitInfo {
  uint32 global_limit = 1;
  uint32 per_collector_limit = 2;
  uint32 burst_limit = 3;
  google.protobuf.Duration window = 4;
}

// RegionInfo provides regional routing information
message RegionInfo {
  string region = 1;
  repeated ServerEndpoint endpoints = 2;
  float load_factor = 3;
  uint32 collector_count = 4;
}

// AckMessage acknowledges received responses
message AckMessage {
  uint64 sequence = 1;
  bool success = 2;
  string message = 3;
}

// ErrorResponse provides detailed error information
message ErrorResponse {
  ErrorCode code = 1;
  string message = 2;
  string details = 3;
  google.protobuf.Timestamp timestamp = 4;
  bool retryable = 5;
  google.protobuf.Duration retry_after = 6;
}

// Enums for type safety and forward compatibility

enum CompressionType {
  COMPRESSION_NONE = 0;
  COMPRESSION_GZIP = 1;
  COMPRESSION_ZSTD = 2;
  COMPRESSION_LZ4 = 3;
  COMPRESSION_SNAPPY = 4;
}

enum CollectorState {
  COLLECTOR_UNKNOWN = 0;
  COLLECTOR_STARTING = 1;
  COLLECTOR_RUNNING = 2;
  COLLECTOR_DEGRADED = 3;
  COLLECTOR_STOPPING = 4;
  COLLECTOR_STOPPED = 5;
  COLLECTOR_ERROR = 6;
}

enum MemoryPressure {
  MEMORY_PRESSURE_NONE = 0;
  MEMORY_PRESSURE_LOW = 1;
  MEMORY_PRESSURE_MEDIUM = 2;
  MEMORY_PRESSURE_HIGH = 3;
  MEMORY_PRESSURE_CRITICAL = 4;
}

enum LoadBalancingStrategy {
  LOAD_BALANCING_ROUND_ROBIN = 0;
  LOAD_BALANCING_LEAST_CONNECTIONS = 1;
  LOAD_BALANCING_WEIGHTED = 2;
  LOAD_BALANCING_CONSISTENT_HASH = 3;
  LOAD_BALANCING_LOCALITY_AWARE = 4;
}

enum HealthStatus {
  HEALTH_UNKNOWN = 0;
  HEALTH_HEALTHY = 1;
  HEALTH_DEGRADED = 2;
  HEALTH_UNHEALTHY = 3;
  HEALTH_MAINTENANCE = 4;
}

enum ErrorCode {
  ERROR_UNKNOWN = 0;
  ERROR_INVALID_REQUEST = 1;
  ERROR_AUTHENTICATION_FAILED = 2;
  ERROR_AUTHORIZATION_FAILED = 3;
  ERROR_RATE_LIMITED = 4;
  ERROR_QUOTA_EXCEEDED = 5;
  ERROR_INVALID_CONFIGURATION = 6;
  ERROR_SERVICE_UNAVAILABLE = 7;
  ERROR_INTERNAL_ERROR = 8;
  ERROR_TIMEOUT = 9;
  ERROR_INVALID_COMPRESSION = 10;
  ERROR_BATCH_TOO_LARGE = 11;
  ERROR_UNSUPPORTED_VERSION = 12;
}