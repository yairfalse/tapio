# API and Correlation Engine Integration

This document explains how the REST API endpoints connect to the real correlation engine in Tapio's 7-day prototype.

## Architecture Overview

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│   gRPC Client   │────▶│   gRPC Server    │────▶│   Correlation   │
│  (Collectors)   │     │  (Event Ingest)  │     │     Engine      │
└─────────────────┘     └──────────────────┘     └────────┬────────┘
                                                           │
                        ┌──────────────────┐               │
                        │  Insight Store   │◀──────────────┘
                        │   (In-Memory)    │
                        └────────┬─────────┘
                                 │
┌─────────────────┐     ┌────────▼─────────┐
│   REST Client   │◀────│   REST API       │
│  (CLI/WebUI)    │     │   (Query API)    │
└─────────────────┘     └──────────────────┘
```

## Key Components

### 1. Enhanced Main Server (`cmd/tapio-server/main_enhanced.go`)

The main server now starts both gRPC and REST API servers:

```go
// Start gRPC server for event ingestion
grpcServer.Start()

// Start REST API server for queries
go apiServer.Start()
```

Both servers share:
- The same correlation engine instance
- A shared InsightStore for storing/retrieving insights
- Common metrics collector

### 2. PerfectEngineWithStore (`pkg/correlation/engine_with_store.go`)

This wrapper around the PerfectEngine automatically stores insights:

```go
type PerfectEngineWithStore struct {
    baseEngine   *PerfectEngine
    insightStore InsightStore
}

// When processing events, insights are automatically stored
func (e *PerfectEngineWithStore) ProcessOpinionatedEvent(ctx context.Context, event *OpinionatedEvent) error {
    // Process event through correlation engine
    err := e.baseEngine.ProcessOpinionatedEvent(ctx, event)
    
    // Extract and store generated insights
    insights := e.extractInsightsFromEvent(event)
    for _, insight := range insights {
        e.insightStore.Store(insight)
    }
}
```

### 3. REST API Server (`internal/api/server_enhanced.go`)

The API server reads from the shared InsightStore:

```go
// GET /api/v1/insights/:namespace/:resource
func (s *Server) getResourceInsights(c *gin.Context) {
    insights := s.insightStore.GetInsights(resource, namespace)
    c.JSON(200, insights)
}
```

## Data Flow

1. **Event Ingestion**:
   - Collectors send events via gRPC streaming
   - gRPC server receives events and forwards to correlation engine

2. **Correlation Processing**:
   - PerfectEngine processes events through multiple correlators
   - Generates insights based on semantic, behavioral, temporal patterns
   - PerfectEngineWithStore automatically stores insights

3. **Insight Storage**:
   - Insights stored in shared InMemoryInsightStore
   - Includes metadata: resource, namespace, severity, predictions

4. **API Queries**:
   - REST API reads from InsightStore
   - Returns insights, predictions, and actionable fixes
   - Real-time data from correlation engine

## API Endpoints Connected to Correlation Engine

### Insight Endpoints
- `GET /api/v1/insights` - All insights from correlation engine
- `GET /api/v1/insights/:namespace/:resource` - Resource-specific insights
- `GET /api/v1/predictions` - Insights with predictions
- `GET /api/v1/fixes/:namespace/:resource` - Actionable items from insights

### Health & Metrics
- `GET /api/v1/health/cluster` - Aggregated health including insight counts
- `GET /admin/metrics` - Correlation engine statistics

### Real-time Features (Planned)
- `GET /api/v1/ws/insights` - WebSocket for streaming new insights
- `POST /api/v1/correlate` - On-demand correlation analysis

## Example: OOM Detection Flow

1. **Event Detection**:
   ```
   Collector → gRPC → "OOM Kill detected for pod api-xyz"
   ```

2. **Correlation Processing**:
   ```go
   // PerfectEngine generates insight
   insight := &Insight{
       Title: "Memory pressure causing OOM kills",
       Severity: "critical",
       Prediction: &Prediction{
           Type: "cascade_failure",
           Probability: 0.85,
       },
       ActionableItems: []*ActionableItem{{
           Description: "Increase memory limit",
           Command: "kubectl patch deployment...",
       }},
   }
   ```

3. **Storage**:
   ```go
   insightStore.Store(insight)
   ```

4. **API Query**:
   ```bash
   curl http://localhost:8888/api/v1/insights/production/api-deployment
   # Returns the OOM insight with predictions and fixes
   ```

## Testing the Integration

Run the test script to verify the connection:

```bash
./examples/api_test.sh
```

This will:
1. Check server health and readiness
2. Query insights generated by correlation engine
3. List predictions and available fixes
4. Show correlation engine metrics

## Configuration

Key configuration in `server.yaml`:

```yaml
correlation:
  enabled: true
  buffer_size: 100000
  analysis_window: 5m
  insight_retention: 24h

api:
  enable_cors: true
  rate_limit_per_min: 1000
  cache_timeout: 30s
```

## Future Enhancements

For production beyond the 7-day prototype:
1. Persistent storage for insights (PostgreSQL/MongoDB)
2. WebSocket support for real-time streaming
3. GraphQL API for flexible queries
4. Insight aggregation and trending
5. Multi-cluster federation