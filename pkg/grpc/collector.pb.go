// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: proto/collector.proto

package grpc

import (
	events "github.com/yairfalse/tapio/pkg/events"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CompressionType int32

const (
	CompressionType_COMPRESSION_NONE   CompressionType = 0
	CompressionType_COMPRESSION_GZIP   CompressionType = 1
	CompressionType_COMPRESSION_ZSTD   CompressionType = 2
	CompressionType_COMPRESSION_LZ4    CompressionType = 3
	CompressionType_COMPRESSION_SNAPPY CompressionType = 4
)

// Enum value maps for CompressionType.
var (
	CompressionType_name = map[int32]string{
		0: "COMPRESSION_NONE",
		1: "COMPRESSION_GZIP",
		2: "COMPRESSION_ZSTD",
		3: "COMPRESSION_LZ4",
		4: "COMPRESSION_SNAPPY",
	}
	CompressionType_value = map[string]int32{
		"COMPRESSION_NONE":   0,
		"COMPRESSION_GZIP":   1,
		"COMPRESSION_ZSTD":   2,
		"COMPRESSION_LZ4":    3,
		"COMPRESSION_SNAPPY": 4,
	}
)

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionType) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_collector_proto_enumTypes[0].Descriptor()
}

func (CompressionType) Type() protoreflect.EnumType {
	return &file_proto_collector_proto_enumTypes[0]
}

func (x CompressionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionType.Descriptor instead.
func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{0}
}

type CollectorState int32

const (
	CollectorState_COLLECTOR_UNKNOWN  CollectorState = 0
	CollectorState_COLLECTOR_STARTING CollectorState = 1
	CollectorState_COLLECTOR_RUNNING  CollectorState = 2
	CollectorState_COLLECTOR_DEGRADED CollectorState = 3
	CollectorState_COLLECTOR_STOPPING CollectorState = 4
	CollectorState_COLLECTOR_STOPPED  CollectorState = 5
	CollectorState_COLLECTOR_ERROR    CollectorState = 6
)

// Enum value maps for CollectorState.
var (
	CollectorState_name = map[int32]string{
		0: "COLLECTOR_UNKNOWN",
		1: "COLLECTOR_STARTING",
		2: "COLLECTOR_RUNNING",
		3: "COLLECTOR_DEGRADED",
		4: "COLLECTOR_STOPPING",
		5: "COLLECTOR_STOPPED",
		6: "COLLECTOR_ERROR",
	}
	CollectorState_value = map[string]int32{
		"COLLECTOR_UNKNOWN":  0,
		"COLLECTOR_STARTING": 1,
		"COLLECTOR_RUNNING":  2,
		"COLLECTOR_DEGRADED": 3,
		"COLLECTOR_STOPPING": 4,
		"COLLECTOR_STOPPED":  5,
		"COLLECTOR_ERROR":    6,
	}
)

func (x CollectorState) Enum() *CollectorState {
	p := new(CollectorState)
	*p = x
	return p
}

func (x CollectorState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CollectorState) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_collector_proto_enumTypes[1].Descriptor()
}

func (CollectorState) Type() protoreflect.EnumType {
	return &file_proto_collector_proto_enumTypes[1]
}

func (x CollectorState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CollectorState.Descriptor instead.
func (CollectorState) EnumDescriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{1}
}

type MemoryPressure int32

const (
	MemoryPressure_MEMORY_PRESSURE_NONE     MemoryPressure = 0
	MemoryPressure_MEMORY_PRESSURE_LOW      MemoryPressure = 1
	MemoryPressure_MEMORY_PRESSURE_MEDIUM   MemoryPressure = 2
	MemoryPressure_MEMORY_PRESSURE_HIGH     MemoryPressure = 3
	MemoryPressure_MEMORY_PRESSURE_CRITICAL MemoryPressure = 4
)

// Enum value maps for MemoryPressure.
var (
	MemoryPressure_name = map[int32]string{
		0: "MEMORY_PRESSURE_NONE",
		1: "MEMORY_PRESSURE_LOW",
		2: "MEMORY_PRESSURE_MEDIUM",
		3: "MEMORY_PRESSURE_HIGH",
		4: "MEMORY_PRESSURE_CRITICAL",
	}
	MemoryPressure_value = map[string]int32{
		"MEMORY_PRESSURE_NONE":     0,
		"MEMORY_PRESSURE_LOW":      1,
		"MEMORY_PRESSURE_MEDIUM":   2,
		"MEMORY_PRESSURE_HIGH":     3,
		"MEMORY_PRESSURE_CRITICAL": 4,
	}
)

func (x MemoryPressure) Enum() *MemoryPressure {
	p := new(MemoryPressure)
	*p = x
	return p
}

func (x MemoryPressure) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MemoryPressure) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_collector_proto_enumTypes[2].Descriptor()
}

func (MemoryPressure) Type() protoreflect.EnumType {
	return &file_proto_collector_proto_enumTypes[2]
}

func (x MemoryPressure) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MemoryPressure.Descriptor instead.
func (MemoryPressure) EnumDescriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{2}
}

type LoadBalancingStrategy int32

const (
	LoadBalancingStrategy_LOAD_BALANCING_ROUND_ROBIN       LoadBalancingStrategy = 0
	LoadBalancingStrategy_LOAD_BALANCING_LEAST_CONNECTIONS LoadBalancingStrategy = 1
	LoadBalancingStrategy_LOAD_BALANCING_WEIGHTED          LoadBalancingStrategy = 2
	LoadBalancingStrategy_LOAD_BALANCING_CONSISTENT_HASH   LoadBalancingStrategy = 3
	LoadBalancingStrategy_LOAD_BALANCING_LOCALITY_AWARE    LoadBalancingStrategy = 4
)

// Enum value maps for LoadBalancingStrategy.
var (
	LoadBalancingStrategy_name = map[int32]string{
		0: "LOAD_BALANCING_ROUND_ROBIN",
		1: "LOAD_BALANCING_LEAST_CONNECTIONS",
		2: "LOAD_BALANCING_WEIGHTED",
		3: "LOAD_BALANCING_CONSISTENT_HASH",
		4: "LOAD_BALANCING_LOCALITY_AWARE",
	}
	LoadBalancingStrategy_value = map[string]int32{
		"LOAD_BALANCING_ROUND_ROBIN":       0,
		"LOAD_BALANCING_LEAST_CONNECTIONS": 1,
		"LOAD_BALANCING_WEIGHTED":          2,
		"LOAD_BALANCING_CONSISTENT_HASH":   3,
		"LOAD_BALANCING_LOCALITY_AWARE":    4,
	}
)

func (x LoadBalancingStrategy) Enum() *LoadBalancingStrategy {
	p := new(LoadBalancingStrategy)
	*p = x
	return p
}

func (x LoadBalancingStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LoadBalancingStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_collector_proto_enumTypes[3].Descriptor()
}

func (LoadBalancingStrategy) Type() protoreflect.EnumType {
	return &file_proto_collector_proto_enumTypes[3]
}

func (x LoadBalancingStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LoadBalancingStrategy.Descriptor instead.
func (LoadBalancingStrategy) EnumDescriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{3}
}

type HealthStatus int32

const (
	HealthStatus_HEALTH_UNKNOWN     HealthStatus = 0
	HealthStatus_HEALTH_HEALTHY     HealthStatus = 1
	HealthStatus_HEALTH_DEGRADED    HealthStatus = 2
	HealthStatus_HEALTH_UNHEALTHY   HealthStatus = 3
	HealthStatus_HEALTH_MAINTENANCE HealthStatus = 4
)

// Enum value maps for HealthStatus.
var (
	HealthStatus_name = map[int32]string{
		0: "HEALTH_UNKNOWN",
		1: "HEALTH_HEALTHY",
		2: "HEALTH_DEGRADED",
		3: "HEALTH_UNHEALTHY",
		4: "HEALTH_MAINTENANCE",
	}
	HealthStatus_value = map[string]int32{
		"HEALTH_UNKNOWN":     0,
		"HEALTH_HEALTHY":     1,
		"HEALTH_DEGRADED":    2,
		"HEALTH_UNHEALTHY":   3,
		"HEALTH_MAINTENANCE": 4,
	}
)

func (x HealthStatus) Enum() *HealthStatus {
	p := new(HealthStatus)
	*p = x
	return p
}

func (x HealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_collector_proto_enumTypes[4].Descriptor()
}

func (HealthStatus) Type() protoreflect.EnumType {
	return &file_proto_collector_proto_enumTypes[4]
}

func (x HealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HealthStatus.Descriptor instead.
func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{4}
}

type ErrorCode int32

const (
	ErrorCode_ERROR_UNKNOWN               ErrorCode = 0
	ErrorCode_ERROR_INVALID_REQUEST       ErrorCode = 1
	ErrorCode_ERROR_AUTHENTICATION_FAILED ErrorCode = 2
	ErrorCode_ERROR_AUTHORIZATION_FAILED  ErrorCode = 3
	ErrorCode_ERROR_RATE_LIMITED          ErrorCode = 4
	ErrorCode_ERROR_QUOTA_EXCEEDED        ErrorCode = 5
	ErrorCode_ERROR_INVALID_CONFIGURATION ErrorCode = 6
	ErrorCode_ERROR_SERVICE_UNAVAILABLE   ErrorCode = 7
	ErrorCode_ERROR_INTERNAL_ERROR        ErrorCode = 8
	ErrorCode_ERROR_TIMEOUT               ErrorCode = 9
	ErrorCode_ERROR_INVALID_COMPRESSION   ErrorCode = 10
	ErrorCode_ERROR_BATCH_TOO_LARGE       ErrorCode = 11
	ErrorCode_ERROR_UNSUPPORTED_VERSION   ErrorCode = 12
)

// Enum value maps for ErrorCode.
var (
	ErrorCode_name = map[int32]string{
		0:  "ERROR_UNKNOWN",
		1:  "ERROR_INVALID_REQUEST",
		2:  "ERROR_AUTHENTICATION_FAILED",
		3:  "ERROR_AUTHORIZATION_FAILED",
		4:  "ERROR_RATE_LIMITED",
		5:  "ERROR_QUOTA_EXCEEDED",
		6:  "ERROR_INVALID_CONFIGURATION",
		7:  "ERROR_SERVICE_UNAVAILABLE",
		8:  "ERROR_INTERNAL_ERROR",
		9:  "ERROR_TIMEOUT",
		10: "ERROR_INVALID_COMPRESSION",
		11: "ERROR_BATCH_TOO_LARGE",
		12: "ERROR_UNSUPPORTED_VERSION",
	}
	ErrorCode_value = map[string]int32{
		"ERROR_UNKNOWN":               0,
		"ERROR_INVALID_REQUEST":       1,
		"ERROR_AUTHENTICATION_FAILED": 2,
		"ERROR_AUTHORIZATION_FAILED":  3,
		"ERROR_RATE_LIMITED":          4,
		"ERROR_QUOTA_EXCEEDED":        5,
		"ERROR_INVALID_CONFIGURATION": 6,
		"ERROR_SERVICE_UNAVAILABLE":   7,
		"ERROR_INTERNAL_ERROR":        8,
		"ERROR_TIMEOUT":               9,
		"ERROR_INVALID_COMPRESSION":   10,
		"ERROR_BATCH_TOO_LARGE":       11,
		"ERROR_UNSUPPORTED_VERSION":   12,
	}
)

func (x ErrorCode) Enum() *ErrorCode {
	p := new(ErrorCode)
	*p = x
	return p
}

func (x ErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_proto_collector_proto_enumTypes[5].Descriptor()
}

func (ErrorCode) Type() protoreflect.EnumType {
	return &file_proto_collector_proto_enumTypes[5]
}

func (x ErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ErrorCode.Descriptor instead.
func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{5}
}

// StreamRequest contains events or control messages from collector to server
type StreamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Request sequence number for ordering and acknowledgment
	Sequence uint64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Collector identifier
	CollectorId string `protobuf:"bytes,2,opt,name=collector_id,json=collectorId,proto3" json:"collector_id,omitempty"`
	// Request payload
	//
	// Types that are valid to be assigned to Payload:
	//
	//	*StreamRequest_Events
	//	*StreamRequest_FlowControl
	//	*StreamRequest_Status
	//	*StreamRequest_Ack
	Payload       isStreamRequest_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamRequest) Reset() {
	*x = StreamRequest{}
	mi := &file_proto_collector_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamRequest) ProtoMessage() {}

func (x *StreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamRequest.ProtoReflect.Descriptor instead.
func (*StreamRequest) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{0}
}

func (x *StreamRequest) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *StreamRequest) GetCollectorId() string {
	if x != nil {
		return x.CollectorId
	}
	return ""
}

func (x *StreamRequest) GetPayload() isStreamRequest_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *StreamRequest) GetEvents() *EventBatch {
	if x != nil {
		if x, ok := x.Payload.(*StreamRequest_Events); ok {
			return x.Events
		}
	}
	return nil
}

func (x *StreamRequest) GetFlowControl() *FlowControlMessage {
	if x != nil {
		if x, ok := x.Payload.(*StreamRequest_FlowControl); ok {
			return x.FlowControl
		}
	}
	return nil
}

func (x *StreamRequest) GetStatus() *CollectorStatus {
	if x != nil {
		if x, ok := x.Payload.(*StreamRequest_Status); ok {
			return x.Status
		}
	}
	return nil
}

func (x *StreamRequest) GetAck() *AckMessage {
	if x != nil {
		if x, ok := x.Payload.(*StreamRequest_Ack); ok {
			return x.Ack
		}
	}
	return nil
}

type isStreamRequest_Payload interface {
	isStreamRequest_Payload()
}

type StreamRequest_Events struct {
	// Batch of events to process
	Events *EventBatch `protobuf:"bytes,10,opt,name=events,proto3,oneof"`
}

type StreamRequest_FlowControl struct {
	// Flow control message
	FlowControl *FlowControlMessage `protobuf:"bytes,11,opt,name=flow_control,json=flowControl,proto3,oneof"`
}

type StreamRequest_Status struct {
	// Collector status update
	Status *CollectorStatus `protobuf:"bytes,12,opt,name=status,proto3,oneof"`
}

type StreamRequest_Ack struct {
	// Acknowledgment of received response
	Ack *AckMessage `protobuf:"bytes,13,opt,name=ack,proto3,oneof"`
}

func (*StreamRequest_Events) isStreamRequest_Payload() {}

func (*StreamRequest_FlowControl) isStreamRequest_Payload() {}

func (*StreamRequest_Status) isStreamRequest_Payload() {}

func (*StreamRequest_Ack) isStreamRequest_Payload() {}

// StreamResponse contains responses and control messages from server to collector
type StreamResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Response sequence number for ordering
	Sequence uint64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// Timestamp when response was generated
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Response payload
	//
	// Types that are valid to be assigned to Payload:
	//
	//	*StreamResponse_EventAck
	//	*StreamResponse_FlowControl
	//	*StreamResponse_ServerStatus
	//	*StreamResponse_Error
	Payload       isStreamResponse_Payload `protobuf_oneof:"payload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamResponse) Reset() {
	*x = StreamResponse{}
	mi := &file_proto_collector_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamResponse) ProtoMessage() {}

func (x *StreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamResponse.ProtoReflect.Descriptor instead.
func (*StreamResponse) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{1}
}

func (x *StreamResponse) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *StreamResponse) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *StreamResponse) GetPayload() isStreamResponse_Payload {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *StreamResponse) GetEventAck() *EventAck {
	if x != nil {
		if x, ok := x.Payload.(*StreamResponse_EventAck); ok {
			return x.EventAck
		}
	}
	return nil
}

func (x *StreamResponse) GetFlowControl() *FlowControlDirective {
	if x != nil {
		if x, ok := x.Payload.(*StreamResponse_FlowControl); ok {
			return x.FlowControl
		}
	}
	return nil
}

func (x *StreamResponse) GetServerStatus() *ServerStatus {
	if x != nil {
		if x, ok := x.Payload.(*StreamResponse_ServerStatus); ok {
			return x.ServerStatus
		}
	}
	return nil
}

func (x *StreamResponse) GetError() *ErrorResponse {
	if x != nil {
		if x, ok := x.Payload.(*StreamResponse_Error); ok {
			return x.Error
		}
	}
	return nil
}

type isStreamResponse_Payload interface {
	isStreamResponse_Payload()
}

type StreamResponse_EventAck struct {
	// Acknowledgment of processed events
	EventAck *EventAck `protobuf:"bytes,10,opt,name=event_ack,json=eventAck,proto3,oneof"`
}

type StreamResponse_FlowControl struct {
	// Flow control directive
	FlowControl *FlowControlDirective `protobuf:"bytes,11,opt,name=flow_control,json=flowControl,proto3,oneof"`
}

type StreamResponse_ServerStatus struct {
	// Server status or configuration update
	ServerStatus *ServerStatus `protobuf:"bytes,12,opt,name=server_status,json=serverStatus,proto3,oneof"`
}

type StreamResponse_Error struct {
	// Error information
	Error *ErrorResponse `protobuf:"bytes,13,opt,name=error,proto3,oneof"`
}

func (*StreamResponse_EventAck) isStreamResponse_Payload() {}

func (*StreamResponse_FlowControl) isStreamResponse_Payload() {}

func (*StreamResponse_ServerStatus) isStreamResponse_Payload() {}

func (*StreamResponse_Error) isStreamResponse_Payload() {}

// EventBatch contains multiple events for efficient transmission
type EventBatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch identifier for tracking and deduplication
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// When this batch was created
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Source collector information
	CollectorId   string `protobuf:"bytes,3,opt,name=collector_id,json=collectorId,proto3" json:"collector_id,omitempty"`
	CollectorType string `protobuf:"bytes,4,opt,name=collector_type,json=collectorType,proto3" json:"collector_type,omitempty"`
	NodeId        string `protobuf:"bytes,5,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Events in this batch
	Events []*events.UnifiedEvent `protobuf:"bytes,6,rep,name=events,proto3" json:"events,omitempty"`
	// Batch metadata
	Metadata *BatchMetadata `protobuf:"bytes,7,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Compression used for this batch
	Compression CompressionType `protobuf:"varint,8,opt,name=compression,proto3,enum=tapio.collector.v1.CompressionType" json:"compression,omitempty"`
	// Quality metrics for this batch
	Quality       *QualityMetrics `protobuf:"bytes,9,opt,name=quality,proto3" json:"quality,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventBatch) Reset() {
	*x = EventBatch{}
	mi := &file_proto_collector_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventBatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventBatch) ProtoMessage() {}

func (x *EventBatch) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventBatch.ProtoReflect.Descriptor instead.
func (*EventBatch) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{2}
}

func (x *EventBatch) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *EventBatch) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *EventBatch) GetCollectorId() string {
	if x != nil {
		return x.CollectorId
	}
	return ""
}

func (x *EventBatch) GetCollectorType() string {
	if x != nil {
		return x.CollectorType
	}
	return ""
}

func (x *EventBatch) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *EventBatch) GetEvents() []*events.UnifiedEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *EventBatch) GetMetadata() *BatchMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *EventBatch) GetCompression() CompressionType {
	if x != nil {
		return x.Compression
	}
	return CompressionType_COMPRESSION_NONE
}

func (x *EventBatch) GetQuality() *QualityMetrics {
	if x != nil {
		return x.Quality
	}
	return nil
}

// BatchMetadata provides information about the batch
type BatchMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total size of events before compression
	UncompressedSize uint64 `protobuf:"varint,1,opt,name=uncompressed_size,json=uncompressedSize,proto3" json:"uncompressed_size,omitempty"`
	// Size after compression
	CompressedSize uint64 `protobuf:"varint,2,opt,name=compressed_size,json=compressedSize,proto3" json:"compressed_size,omitempty"`
	// Number of events in batch
	EventCount uint32 `protobuf:"varint,3,opt,name=event_count,json=eventCount,proto3" json:"event_count,omitempty"`
	// Time span covered by events in this batch
	TimeSpan *durationpb.Duration `protobuf:"bytes,4,opt,name=time_span,json=timeSpan,proto3" json:"time_span,omitempty"`
	// Events that were dropped due to rate limiting
	DroppedEvents uint32 `protobuf:"varint,5,opt,name=dropped_events,json=droppedEvents,proto3" json:"dropped_events,omitempty"`
	// Checksum for integrity verification
	Checksum      string `protobuf:"bytes,6,opt,name=checksum,proto3" json:"checksum,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BatchMetadata) Reset() {
	*x = BatchMetadata{}
	mi := &file_proto_collector_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BatchMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BatchMetadata) ProtoMessage() {}

func (x *BatchMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BatchMetadata.ProtoReflect.Descriptor instead.
func (*BatchMetadata) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{3}
}

func (x *BatchMetadata) GetUncompressedSize() uint64 {
	if x != nil {
		return x.UncompressedSize
	}
	return 0
}

func (x *BatchMetadata) GetCompressedSize() uint64 {
	if x != nil {
		return x.CompressedSize
	}
	return 0
}

func (x *BatchMetadata) GetEventCount() uint32 {
	if x != nil {
		return x.EventCount
	}
	return 0
}

func (x *BatchMetadata) GetTimeSpan() *durationpb.Duration {
	if x != nil {
		return x.TimeSpan
	}
	return nil
}

func (x *BatchMetadata) GetDroppedEvents() uint32 {
	if x != nil {
		return x.DroppedEvents
	}
	return 0
}

func (x *BatchMetadata) GetChecksum() string {
	if x != nil {
		return x.Checksum
	}
	return ""
}

// QualityMetrics tracks the quality of collected events
type QualityMetrics struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Average confidence score (0.0 to 1.0)
	AvgConfidence float32 `protobuf:"fixed32,1,opt,name=avg_confidence,json=avgConfidence,proto3" json:"avg_confidence,omitempty"`
	// Percentage of events with full context
	ContextCompleteness float32 `protobuf:"fixed32,2,opt,name=context_completeness,json=contextCompleteness,proto3" json:"context_completeness,omitempty"`
	// Processing latency statistics
	ProcessingLatency *LatencyStats `protobuf:"bytes,3,opt,name=processing_latency,json=processingLatency,proto3" json:"processing_latency,omitempty"`
	// Collection latency statistics
	CollectionLatency *LatencyStats `protobuf:"bytes,4,opt,name=collection_latency,json=collectionLatency,proto3" json:"collection_latency,omitempty"`
	// Error rates
	ErrorStats    *ErrorStats `protobuf:"bytes,5,opt,name=error_stats,json=errorStats,proto3" json:"error_stats,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QualityMetrics) Reset() {
	*x = QualityMetrics{}
	mi := &file_proto_collector_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QualityMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QualityMetrics) ProtoMessage() {}

func (x *QualityMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QualityMetrics.ProtoReflect.Descriptor instead.
func (*QualityMetrics) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{4}
}

func (x *QualityMetrics) GetAvgConfidence() float32 {
	if x != nil {
		return x.AvgConfidence
	}
	return 0
}

func (x *QualityMetrics) GetContextCompleteness() float32 {
	if x != nil {
		return x.ContextCompleteness
	}
	return 0
}

func (x *QualityMetrics) GetProcessingLatency() *LatencyStats {
	if x != nil {
		return x.ProcessingLatency
	}
	return nil
}

func (x *QualityMetrics) GetCollectionLatency() *LatencyStats {
	if x != nil {
		return x.CollectionLatency
	}
	return nil
}

func (x *QualityMetrics) GetErrorStats() *ErrorStats {
	if x != nil {
		return x.ErrorStats
	}
	return nil
}

// LatencyStats provides statistical information about latencies
type LatencyStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Min           *durationpb.Duration   `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	Max           *durationpb.Duration   `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	Avg           *durationpb.Duration   `protobuf:"bytes,3,opt,name=avg,proto3" json:"avg,omitempty"`
	P50           *durationpb.Duration   `protobuf:"bytes,4,opt,name=p50,proto3" json:"p50,omitempty"`
	P95           *durationpb.Duration   `protobuf:"bytes,5,opt,name=p95,proto3" json:"p95,omitempty"`
	P99           *durationpb.Duration   `protobuf:"bytes,6,opt,name=p99,proto3" json:"p99,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LatencyStats) Reset() {
	*x = LatencyStats{}
	mi := &file_proto_collector_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LatencyStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LatencyStats) ProtoMessage() {}

func (x *LatencyStats) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LatencyStats.ProtoReflect.Descriptor instead.
func (*LatencyStats) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{5}
}

func (x *LatencyStats) GetMin() *durationpb.Duration {
	if x != nil {
		return x.Min
	}
	return nil
}

func (x *LatencyStats) GetMax() *durationpb.Duration {
	if x != nil {
		return x.Max
	}
	return nil
}

func (x *LatencyStats) GetAvg() *durationpb.Duration {
	if x != nil {
		return x.Avg
	}
	return nil
}

func (x *LatencyStats) GetP50() *durationpb.Duration {
	if x != nil {
		return x.P50
	}
	return nil
}

func (x *LatencyStats) GetP95() *durationpb.Duration {
	if x != nil {
		return x.P95
	}
	return nil
}

func (x *LatencyStats) GetP99() *durationpb.Duration {
	if x != nil {
		return x.P99
	}
	return nil
}

// ErrorStats tracks error rates and types
type ErrorStats struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	TotalErrors         uint32                 `protobuf:"varint,1,opt,name=total_errors,json=totalErrors,proto3" json:"total_errors,omitempty"`
	ValidationErrors    uint32                 `protobuf:"varint,2,opt,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty"`
	SerializationErrors uint32                 `protobuf:"varint,3,opt,name=serialization_errors,json=serializationErrors,proto3" json:"serialization_errors,omitempty"`
	NetworkErrors       uint32                 `protobuf:"varint,4,opt,name=network_errors,json=networkErrors,proto3" json:"network_errors,omitempty"`
	ErrorRate           float32                `protobuf:"fixed32,5,opt,name=error_rate,json=errorRate,proto3" json:"error_rate,omitempty"` // Errors per second
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ErrorStats) Reset() {
	*x = ErrorStats{}
	mi := &file_proto_collector_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErrorStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErrorStats) ProtoMessage() {}

func (x *ErrorStats) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ErrorStats.ProtoReflect.Descriptor instead.
func (*ErrorStats) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{6}
}

func (x *ErrorStats) GetTotalErrors() uint32 {
	if x != nil {
		return x.TotalErrors
	}
	return 0
}

func (x *ErrorStats) GetValidationErrors() uint32 {
	if x != nil {
		return x.ValidationErrors
	}
	return 0
}

func (x *ErrorStats) GetSerializationErrors() uint32 {
	if x != nil {
		return x.SerializationErrors
	}
	return 0
}

func (x *ErrorStats) GetNetworkErrors() uint32 {
	if x != nil {
		return x.NetworkErrors
	}
	return 0
}

func (x *ErrorStats) GetErrorRate() float32 {
	if x != nil {
		return x.ErrorRate
	}
	return 0
}

// FlowControlMessage allows collectors to request flow control changes
type FlowControlMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Requested events per second
	RequestedRate uint32 `protobuf:"varint,1,opt,name=requested_rate,json=requestedRate,proto3" json:"requested_rate,omitempty"`
	// Current buffer utilization (0.0 to 1.0)
	BufferUtilization float32 `protobuf:"fixed32,2,opt,name=buffer_utilization,json=bufferUtilization,proto3" json:"buffer_utilization,omitempty"`
	// Memory pressure indicator
	MemoryPressure MemoryPressure `protobuf:"varint,3,opt,name=memory_pressure,json=memoryPressure,proto3,enum=tapio.collector.v1.MemoryPressure" json:"memory_pressure,omitempty"`
	// Reason for flow control request
	Reason        string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowControlMessage) Reset() {
	*x = FlowControlMessage{}
	mi := &file_proto_collector_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowControlMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControlMessage) ProtoMessage() {}

func (x *FlowControlMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControlMessage.ProtoReflect.Descriptor instead.
func (*FlowControlMessage) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{7}
}

func (x *FlowControlMessage) GetRequestedRate() uint32 {
	if x != nil {
		return x.RequestedRate
	}
	return 0
}

func (x *FlowControlMessage) GetBufferUtilization() float32 {
	if x != nil {
		return x.BufferUtilization
	}
	return 0
}

func (x *FlowControlMessage) GetMemoryPressure() MemoryPressure {
	if x != nil {
		return x.MemoryPressure
	}
	return MemoryPressure_MEMORY_PRESSURE_NONE
}

func (x *FlowControlMessage) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// FlowControlDirective instructs collectors on rate limiting
type FlowControlDirective struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum events per second allowed
	MaxEventsPerSecond uint32 `protobuf:"varint,1,opt,name=max_events_per_second,json=maxEventsPerSecond,proto3" json:"max_events_per_second,omitempty"`
	// Maximum batch size
	MaxBatchSize uint32 `protobuf:"varint,2,opt,name=max_batch_size,json=maxBatchSize,proto3" json:"max_batch_size,omitempty"`
	// Suggested batching interval
	BatchInterval *durationpb.Duration `protobuf:"bytes,3,opt,name=batch_interval,json=batchInterval,proto3" json:"batch_interval,omitempty"`
	// Whether to enable compression
	EnableCompression bool `protobuf:"varint,4,opt,name=enable_compression,json=enableCompression,proto3" json:"enable_compression,omitempty"`
	// Preferred compression algorithm
	CompressionType CompressionType `protobuf:"varint,5,opt,name=compression_type,json=compressionType,proto3,enum=tapio.collector.v1.CompressionType" json:"compression_type,omitempty"`
	// Duration this directive is valid
	ValidDuration *durationpb.Duration `protobuf:"bytes,6,opt,name=valid_duration,json=validDuration,proto3" json:"valid_duration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FlowControlDirective) Reset() {
	*x = FlowControlDirective{}
	mi := &file_proto_collector_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FlowControlDirective) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FlowControlDirective) ProtoMessage() {}

func (x *FlowControlDirective) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FlowControlDirective.ProtoReflect.Descriptor instead.
func (*FlowControlDirective) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{8}
}

func (x *FlowControlDirective) GetMaxEventsPerSecond() uint32 {
	if x != nil {
		return x.MaxEventsPerSecond
	}
	return 0
}

func (x *FlowControlDirective) GetMaxBatchSize() uint32 {
	if x != nil {
		return x.MaxBatchSize
	}
	return 0
}

func (x *FlowControlDirective) GetBatchInterval() *durationpb.Duration {
	if x != nil {
		return x.BatchInterval
	}
	return nil
}

func (x *FlowControlDirective) GetEnableCompression() bool {
	if x != nil {
		return x.EnableCompression
	}
	return false
}

func (x *FlowControlDirective) GetCompressionType() CompressionType {
	if x != nil {
		return x.CompressionType
	}
	return CompressionType_COMPRESSION_NONE
}

func (x *FlowControlDirective) GetValidDuration() *durationpb.Duration {
	if x != nil {
		return x.ValidDuration
	}
	return nil
}

// EventAck acknowledges successful processing of events
type EventAck struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Batch ID that was processed
	BatchId string `protobuf:"bytes,1,opt,name=batch_id,json=batchId,proto3" json:"batch_id,omitempty"`
	// Sequence number of acknowledged request
	RequestSequence uint64 `protobuf:"varint,2,opt,name=request_sequence,json=requestSequence,proto3" json:"request_sequence,omitempty"`
	// Number of events successfully processed
	ProcessedCount uint32 `protobuf:"varint,3,opt,name=processed_count,json=processedCount,proto3" json:"processed_count,omitempty"`
	// Number of events that failed processing
	FailedCount uint32 `protobuf:"varint,4,opt,name=failed_count,json=failedCount,proto3" json:"failed_count,omitempty"`
	// List of event IDs that failed (if any)
	FailedEventIds []string `protobuf:"bytes,5,rep,name=failed_event_ids,json=failedEventIds,proto3" json:"failed_event_ids,omitempty"`
	// Processing time for this batch
	ProcessingTime *durationpb.Duration `protobuf:"bytes,6,opt,name=processing_time,json=processingTime,proto3" json:"processing_time,omitempty"`
	// Server timestamp when processing completed
	ProcessedAt   *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=processed_at,json=processedAt,proto3" json:"processed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventAck) Reset() {
	*x = EventAck{}
	mi := &file_proto_collector_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventAck) ProtoMessage() {}

func (x *EventAck) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventAck.ProtoReflect.Descriptor instead.
func (*EventAck) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{9}
}

func (x *EventAck) GetBatchId() string {
	if x != nil {
		return x.BatchId
	}
	return ""
}

func (x *EventAck) GetRequestSequence() uint64 {
	if x != nil {
		return x.RequestSequence
	}
	return 0
}

func (x *EventAck) GetProcessedCount() uint32 {
	if x != nil {
		return x.ProcessedCount
	}
	return 0
}

func (x *EventAck) GetFailedCount() uint32 {
	if x != nil {
		return x.FailedCount
	}
	return 0
}

func (x *EventAck) GetFailedEventIds() []string {
	if x != nil {
		return x.FailedEventIds
	}
	return nil
}

func (x *EventAck) GetProcessingTime() *durationpb.Duration {
	if x != nil {
		return x.ProcessingTime
	}
	return nil
}

func (x *EventAck) GetProcessedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ProcessedAt
	}
	return nil
}

// CollectorStatus reports collector health and statistics
type CollectorStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current state of the collector
	State CollectorState `protobuf:"varint,1,opt,name=state,proto3,enum=tapio.collector.v1.CollectorState" json:"state,omitempty"`
	// Resource utilization
	Resources *ResourceUtilization `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// Collection statistics
	Stats *CollectionStats `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	// Current configuration version
	ConfigVersion string `protobuf:"bytes,4,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	// Uptime of the collector
	Uptime *durationpb.Duration `protobuf:"bytes,5,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// Last known issues or warnings
	Warnings      []string `protobuf:"bytes,6,rep,name=warnings,proto3" json:"warnings,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CollectorStatus) Reset() {
	*x = CollectorStatus{}
	mi := &file_proto_collector_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CollectorStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectorStatus) ProtoMessage() {}

func (x *CollectorStatus) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CollectorStatus.ProtoReflect.Descriptor instead.
func (*CollectorStatus) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{10}
}

func (x *CollectorStatus) GetState() CollectorState {
	if x != nil {
		return x.State
	}
	return CollectorState_COLLECTOR_UNKNOWN
}

func (x *CollectorStatus) GetResources() *ResourceUtilization {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *CollectorStatus) GetStats() *CollectionStats {
	if x != nil {
		return x.Stats
	}
	return nil
}

func (x *CollectorStatus) GetConfigVersion() string {
	if x != nil {
		return x.ConfigVersion
	}
	return ""
}

func (x *CollectorStatus) GetUptime() *durationpb.Duration {
	if x != nil {
		return x.Uptime
	}
	return nil
}

func (x *CollectorStatus) GetWarnings() []string {
	if x != nil {
		return x.Warnings
	}
	return nil
}

// ServerStatus provides server health and load information
type ServerStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current server load (0.0 to 1.0)
	Load float32 `protobuf:"fixed32,1,opt,name=load,proto3" json:"load,omitempty"`
	// Available capacity for new connections
	AvailableCapacity uint32 `protobuf:"varint,2,opt,name=available_capacity,json=availableCapacity,proto3" json:"available_capacity,omitempty"`
	// Current number of connected collectors
	ConnectedCollectors uint32 `protobuf:"varint,3,opt,name=connected_collectors,json=connectedCollectors,proto3" json:"connected_collectors,omitempty"`
	// Server configuration version
	ConfigVersion string `protobuf:"bytes,4,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	// Rate limiting information
	RateLimits *RateLimitInfo `protobuf:"bytes,5,opt,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	// Regional routing information
	Regions       []*RegionInfo `protobuf:"bytes,6,rep,name=regions,proto3" json:"regions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerStatus) Reset() {
	*x = ServerStatus{}
	mi := &file_proto_collector_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerStatus) ProtoMessage() {}

func (x *ServerStatus) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerStatus.ProtoReflect.Descriptor instead.
func (*ServerStatus) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{11}
}

func (x *ServerStatus) GetLoad() float32 {
	if x != nil {
		return x.Load
	}
	return 0
}

func (x *ServerStatus) GetAvailableCapacity() uint32 {
	if x != nil {
		return x.AvailableCapacity
	}
	return 0
}

func (x *ServerStatus) GetConnectedCollectors() uint32 {
	if x != nil {
		return x.ConnectedCollectors
	}
	return 0
}

func (x *ServerStatus) GetConfigVersion() string {
	if x != nil {
		return x.ConfigVersion
	}
	return ""
}

func (x *ServerStatus) GetRateLimits() *RateLimitInfo {
	if x != nil {
		return x.RateLimits
	}
	return nil
}

func (x *ServerStatus) GetRegions() []*RegionInfo {
	if x != nil {
		return x.Regions
	}
	return nil
}

// ResourceUtilization tracks collector resource usage
type ResourceUtilization struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CPU usage percentage (0.0 to 1.0)
	CpuUsage float32 `protobuf:"fixed32,1,opt,name=cpu_usage,json=cpuUsage,proto3" json:"cpu_usage,omitempty"`
	// Memory usage in bytes
	MemoryBytes uint64 `protobuf:"varint,2,opt,name=memory_bytes,json=memoryBytes,proto3" json:"memory_bytes,omitempty"`
	// Memory limit in bytes
	MemoryLimit uint64 `protobuf:"varint,3,opt,name=memory_limit,json=memoryLimit,proto3" json:"memory_limit,omitempty"`
	// Network bandwidth usage
	Network *NetworkUtilization `protobuf:"bytes,4,opt,name=network,proto3" json:"network,omitempty"`
	// Disk I/O statistics
	Disk          *DiskUtilization `protobuf:"bytes,5,opt,name=disk,proto3" json:"disk,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResourceUtilization) Reset() {
	*x = ResourceUtilization{}
	mi := &file_proto_collector_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourceUtilization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourceUtilization) ProtoMessage() {}

func (x *ResourceUtilization) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourceUtilization.ProtoReflect.Descriptor instead.
func (*ResourceUtilization) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{12}
}

func (x *ResourceUtilization) GetCpuUsage() float32 {
	if x != nil {
		return x.CpuUsage
	}
	return 0
}

func (x *ResourceUtilization) GetMemoryBytes() uint64 {
	if x != nil {
		return x.MemoryBytes
	}
	return 0
}

func (x *ResourceUtilization) GetMemoryLimit() uint64 {
	if x != nil {
		return x.MemoryLimit
	}
	return 0
}

func (x *ResourceUtilization) GetNetwork() *NetworkUtilization {
	if x != nil {
		return x.Network
	}
	return nil
}

func (x *ResourceUtilization) GetDisk() *DiskUtilization {
	if x != nil {
		return x.Disk
	}
	return nil
}

// NetworkUtilization tracks network resource usage
type NetworkUtilization struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Bytes per second sent
	BytesSentPerSec uint64 `protobuf:"varint,1,opt,name=bytes_sent_per_sec,json=bytesSentPerSec,proto3" json:"bytes_sent_per_sec,omitempty"`
	// Bytes per second received
	BytesReceivedPerSec uint64 `protobuf:"varint,2,opt,name=bytes_received_per_sec,json=bytesReceivedPerSec,proto3" json:"bytes_received_per_sec,omitempty"`
	// Current number of connections
	Connections uint32 `protobuf:"varint,3,opt,name=connections,proto3" json:"connections,omitempty"`
	// Network latency to server
	Latency       *durationpb.Duration `protobuf:"bytes,4,opt,name=latency,proto3" json:"latency,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkUtilization) Reset() {
	*x = NetworkUtilization{}
	mi := &file_proto_collector_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkUtilization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkUtilization) ProtoMessage() {}

func (x *NetworkUtilization) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkUtilization.ProtoReflect.Descriptor instead.
func (*NetworkUtilization) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{13}
}

func (x *NetworkUtilization) GetBytesSentPerSec() uint64 {
	if x != nil {
		return x.BytesSentPerSec
	}
	return 0
}

func (x *NetworkUtilization) GetBytesReceivedPerSec() uint64 {
	if x != nil {
		return x.BytesReceivedPerSec
	}
	return 0
}

func (x *NetworkUtilization) GetConnections() uint32 {
	if x != nil {
		return x.Connections
	}
	return 0
}

func (x *NetworkUtilization) GetLatency() *durationpb.Duration {
	if x != nil {
		return x.Latency
	}
	return nil
}

// DiskUtilization tracks disk I/O usage
type DiskUtilization struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Reads per second
	ReadsPerSec uint64 `protobuf:"varint,1,opt,name=reads_per_sec,json=readsPerSec,proto3" json:"reads_per_sec,omitempty"`
	// Writes per second
	WritesPerSec uint64 `protobuf:"varint,2,opt,name=writes_per_sec,json=writesPerSec,proto3" json:"writes_per_sec,omitempty"`
	// Bytes read per second
	BytesReadPerSec uint64 `protobuf:"varint,3,opt,name=bytes_read_per_sec,json=bytesReadPerSec,proto3" json:"bytes_read_per_sec,omitempty"`
	// Bytes written per second
	BytesWrittenPerSec uint64 `protobuf:"varint,4,opt,name=bytes_written_per_sec,json=bytesWrittenPerSec,proto3" json:"bytes_written_per_sec,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *DiskUtilization) Reset() {
	*x = DiskUtilization{}
	mi := &file_proto_collector_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DiskUtilization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DiskUtilization) ProtoMessage() {}

func (x *DiskUtilization) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DiskUtilization.ProtoReflect.Descriptor instead.
func (*DiskUtilization) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{14}
}

func (x *DiskUtilization) GetReadsPerSec() uint64 {
	if x != nil {
		return x.ReadsPerSec
	}
	return 0
}

func (x *DiskUtilization) GetWritesPerSec() uint64 {
	if x != nil {
		return x.WritesPerSec
	}
	return 0
}

func (x *DiskUtilization) GetBytesReadPerSec() uint64 {
	if x != nil {
		return x.BytesReadPerSec
	}
	return 0
}

func (x *DiskUtilization) GetBytesWrittenPerSec() uint64 {
	if x != nil {
		return x.BytesWrittenPerSec
	}
	return 0
}

// CollectionStats tracks collection performance metrics
type CollectionStats struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Total events collected since start
	TotalEvents uint64 `protobuf:"varint,1,opt,name=total_events,json=totalEvents,proto3" json:"total_events,omitempty"`
	// Events per second (current rate)
	EventsPerSecond float32 `protobuf:"fixed32,2,opt,name=events_per_second,json=eventsPerSecond,proto3" json:"events_per_second,omitempty"`
	// Total bytes processed
	TotalBytes uint64 `protobuf:"varint,3,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// Bytes per second (current rate)
	BytesPerSecond float32 `protobuf:"fixed32,4,opt,name=bytes_per_second,json=bytesPerSecond,proto3" json:"bytes_per_second,omitempty"`
	// Number of batches sent
	BatchesSent uint64 `protobuf:"varint,5,opt,name=batches_sent,json=batchesSent,proto3" json:"batches_sent,omitempty"`
	// Average batch size
	AvgBatchSize float32 `protobuf:"fixed32,6,opt,name=avg_batch_size,json=avgBatchSize,proto3" json:"avg_batch_size,omitempty"`
	// Error counters
	Errors        *ErrorCounters `protobuf:"bytes,7,opt,name=errors,proto3" json:"errors,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CollectionStats) Reset() {
	*x = CollectionStats{}
	mi := &file_proto_collector_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CollectionStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectionStats) ProtoMessage() {}

func (x *CollectionStats) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CollectionStats.ProtoReflect.Descriptor instead.
func (*CollectionStats) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{15}
}

func (x *CollectionStats) GetTotalEvents() uint64 {
	if x != nil {
		return x.TotalEvents
	}
	return 0
}

func (x *CollectionStats) GetEventsPerSecond() float32 {
	if x != nil {
		return x.EventsPerSecond
	}
	return 0
}

func (x *CollectionStats) GetTotalBytes() uint64 {
	if x != nil {
		return x.TotalBytes
	}
	return 0
}

func (x *CollectionStats) GetBytesPerSecond() float32 {
	if x != nil {
		return x.BytesPerSecond
	}
	return 0
}

func (x *CollectionStats) GetBatchesSent() uint64 {
	if x != nil {
		return x.BatchesSent
	}
	return 0
}

func (x *CollectionStats) GetAvgBatchSize() float32 {
	if x != nil {
		return x.AvgBatchSize
	}
	return 0
}

func (x *CollectionStats) GetErrors() *ErrorCounters {
	if x != nil {
		return x.Errors
	}
	return nil
}

// ErrorCounters tracks various types of errors
type ErrorCounters struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	CollectionErrors    uint64                 `protobuf:"varint,1,opt,name=collection_errors,json=collectionErrors,proto3" json:"collection_errors,omitempty"`
	SerializationErrors uint64                 `protobuf:"varint,2,opt,name=serialization_errors,json=serializationErrors,proto3" json:"serialization_errors,omitempty"`
	NetworkErrors       uint64                 `protobuf:"varint,3,opt,name=network_errors,json=networkErrors,proto3" json:"network_errors,omitempty"`
	ValidationErrors    uint64                 `protobuf:"varint,4,opt,name=validation_errors,json=validationErrors,proto3" json:"validation_errors,omitempty"`
	RateLimitErrors     uint64                 `protobuf:"varint,5,opt,name=rate_limit_errors,json=rateLimitErrors,proto3" json:"rate_limit_errors,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *ErrorCounters) Reset() {
	*x = ErrorCounters{}
	mi := &file_proto_collector_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErrorCounters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErrorCounters) ProtoMessage() {}

func (x *ErrorCounters) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ErrorCounters.ProtoReflect.Descriptor instead.
func (*ErrorCounters) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{16}
}

func (x *ErrorCounters) GetCollectionErrors() uint64 {
	if x != nil {
		return x.CollectionErrors
	}
	return 0
}

func (x *ErrorCounters) GetSerializationErrors() uint64 {
	if x != nil {
		return x.SerializationErrors
	}
	return 0
}

func (x *ErrorCounters) GetNetworkErrors() uint64 {
	if x != nil {
		return x.NetworkErrors
	}
	return 0
}

func (x *ErrorCounters) GetValidationErrors() uint64 {
	if x != nil {
		return x.ValidationErrors
	}
	return 0
}

func (x *ErrorCounters) GetRateLimitErrors() uint64 {
	if x != nil {
		return x.RateLimitErrors
	}
	return 0
}

// EventBatchRequest for non-streaming batch sending
type EventBatchRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Batch         *EventBatch            `protobuf:"bytes,1,opt,name=batch,proto3" json:"batch,omitempty"`
	RequireAck    bool                   `protobuf:"varint,2,opt,name=require_ack,json=requireAck,proto3" json:"require_ack,omitempty"`
	Timeout       *durationpb.Duration   `protobuf:"bytes,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventBatchRequest) Reset() {
	*x = EventBatchRequest{}
	mi := &file_proto_collector_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventBatchRequest) ProtoMessage() {}

func (x *EventBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventBatchRequest.ProtoReflect.Descriptor instead.
func (*EventBatchRequest) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{17}
}

func (x *EventBatchRequest) GetBatch() *EventBatch {
	if x != nil {
		return x.Batch
	}
	return nil
}

func (x *EventBatchRequest) GetRequireAck() bool {
	if x != nil {
		return x.RequireAck
	}
	return false
}

func (x *EventBatchRequest) GetTimeout() *durationpb.Duration {
	if x != nil {
		return x.Timeout
	}
	return nil
}

// EventBatchResponse for non-streaming batch responses
type EventBatchResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Ack           *EventAck              `protobuf:"bytes,3,opt,name=ack,proto3" json:"ack,omitempty"`
	FlowControl   *FlowControlDirective  `protobuf:"bytes,4,opt,name=flow_control,json=flowControl,proto3" json:"flow_control,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EventBatchResponse) Reset() {
	*x = EventBatchResponse{}
	mi := &file_proto_collector_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EventBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EventBatchResponse) ProtoMessage() {}

func (x *EventBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EventBatchResponse.ProtoReflect.Descriptor instead.
func (*EventBatchResponse) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{18}
}

func (x *EventBatchResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *EventBatchResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *EventBatchResponse) GetAck() *EventAck {
	if x != nil {
		return x.Ack
	}
	return nil
}

func (x *EventBatchResponse) GetFlowControl() *FlowControlDirective {
	if x != nil {
		return x.FlowControl
	}
	return nil
}

// CollectorRegistration registers a collector with the server
type CollectorRegistration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique collector identifier
	CollectorId string `protobuf:"bytes,1,opt,name=collector_id,json=collectorId,proto3" json:"collector_id,omitempty"`
	// Type of collector (ebpf, k8s, systemd, etc.)
	CollectorType string `protobuf:"bytes,2,opt,name=collector_type,json=collectorType,proto3" json:"collector_type,omitempty"`
	// Version of the collector software
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// Node information where collector is running
	Node *NodeInfo `protobuf:"bytes,4,opt,name=node,proto3" json:"node,omitempty"`
	// Collector capabilities
	Capabilities *CollectorCapabilities `protobuf:"bytes,5,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	// Requested configuration
	ConfigRequest *ConfigurationRequest `protobuf:"bytes,6,opt,name=config_request,json=configRequest,proto3" json:"config_request,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CollectorRegistration) Reset() {
	*x = CollectorRegistration{}
	mi := &file_proto_collector_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CollectorRegistration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectorRegistration) ProtoMessage() {}

func (x *CollectorRegistration) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CollectorRegistration.ProtoReflect.Descriptor instead.
func (*CollectorRegistration) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{19}
}

func (x *CollectorRegistration) GetCollectorId() string {
	if x != nil {
		return x.CollectorId
	}
	return ""
}

func (x *CollectorRegistration) GetCollectorType() string {
	if x != nil {
		return x.CollectorType
	}
	return ""
}

func (x *CollectorRegistration) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *CollectorRegistration) GetNode() *NodeInfo {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *CollectorRegistration) GetCapabilities() *CollectorCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *CollectorRegistration) GetConfigRequest() *ConfigurationRequest {
	if x != nil {
		return x.ConfigRequest
	}
	return nil
}

// NodeInfo provides information about the node running the collector
type NodeInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        string                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Hostname      string                 `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Os            string                 `protobuf:"bytes,3,opt,name=os,proto3" json:"os,omitempty"`
	Architecture  string                 `protobuf:"bytes,4,opt,name=architecture,proto3" json:"architecture,omitempty"`
	KernelVersion string                 `protobuf:"bytes,5,opt,name=kernel_version,json=kernelVersion,proto3" json:"kernel_version,omitempty"`
	Region        string                 `protobuf:"bytes,6,opt,name=region,proto3" json:"region,omitempty"`
	Zone          string                 `protobuf:"bytes,7,opt,name=zone,proto3" json:"zone,omitempty"`
	Labels        map[string]string      `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeInfo) Reset() {
	*x = NodeInfo{}
	mi := &file_proto_collector_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeInfo) ProtoMessage() {}

func (x *NodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeInfo.ProtoReflect.Descriptor instead.
func (*NodeInfo) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{20}
}

func (x *NodeInfo) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *NodeInfo) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *NodeInfo) GetOs() string {
	if x != nil {
		return x.Os
	}
	return ""
}

func (x *NodeInfo) GetArchitecture() string {
	if x != nil {
		return x.Architecture
	}
	return ""
}

func (x *NodeInfo) GetKernelVersion() string {
	if x != nil {
		return x.KernelVersion
	}
	return ""
}

func (x *NodeInfo) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *NodeInfo) GetZone() string {
	if x != nil {
		return x.Zone
	}
	return ""
}

func (x *NodeInfo) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// CollectorCapabilities describes what the collector can do
type CollectorCapabilities struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum events per second this collector can handle
	MaxEventsPerSecond uint32 `protobuf:"varint,1,opt,name=max_events_per_second,json=maxEventsPerSecond,proto3" json:"max_events_per_second,omitempty"`
	// Supported compression algorithms
	SupportedCompression []CompressionType `protobuf:"varint,2,rep,packed,name=supported_compression,json=supportedCompression,proto3,enum=tapio.collector.v1.CompressionType" json:"supported_compression,omitempty"`
	// Supported event types
	SupportedEventTypes []string `protobuf:"bytes,3,rep,name=supported_event_types,json=supportedEventTypes,proto3" json:"supported_event_types,omitempty"`
	// Whether collector supports streaming
	SupportsStreaming bool `protobuf:"varint,4,opt,name=supports_streaming,json=supportsStreaming,proto3" json:"supports_streaming,omitempty"`
	// Whether collector supports batching
	SupportsBatching bool `protobuf:"varint,5,opt,name=supports_batching,json=supportsBatching,proto3" json:"supports_batching,omitempty"`
	// Maximum batch size supported
	MaxBatchSize uint32 `protobuf:"varint,6,opt,name=max_batch_size,json=maxBatchSize,proto3" json:"max_batch_size,omitempty"`
	// Buffer size in bytes
	BufferSize    uint64 `protobuf:"varint,7,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CollectorCapabilities) Reset() {
	*x = CollectorCapabilities{}
	mi := &file_proto_collector_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CollectorCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectorCapabilities) ProtoMessage() {}

func (x *CollectorCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CollectorCapabilities.ProtoReflect.Descriptor instead.
func (*CollectorCapabilities) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{21}
}

func (x *CollectorCapabilities) GetMaxEventsPerSecond() uint32 {
	if x != nil {
		return x.MaxEventsPerSecond
	}
	return 0
}

func (x *CollectorCapabilities) GetSupportedCompression() []CompressionType {
	if x != nil {
		return x.SupportedCompression
	}
	return nil
}

func (x *CollectorCapabilities) GetSupportedEventTypes() []string {
	if x != nil {
		return x.SupportedEventTypes
	}
	return nil
}

func (x *CollectorCapabilities) GetSupportsStreaming() bool {
	if x != nil {
		return x.SupportsStreaming
	}
	return false
}

func (x *CollectorCapabilities) GetSupportsBatching() bool {
	if x != nil {
		return x.SupportsBatching
	}
	return false
}

func (x *CollectorCapabilities) GetMaxBatchSize() uint32 {
	if x != nil {
		return x.MaxBatchSize
	}
	return 0
}

func (x *CollectorCapabilities) GetBufferSize() uint64 {
	if x != nil {
		return x.BufferSize
	}
	return 0
}

// ConfigurationRequest specifies desired collector configuration
type ConfigurationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Preferred events per second
	PreferredRate uint32 `protobuf:"varint,1,opt,name=preferred_rate,json=preferredRate,proto3" json:"preferred_rate,omitempty"`
	// Preferred batch size
	PreferredBatchSize uint32 `protobuf:"varint,2,opt,name=preferred_batch_size,json=preferredBatchSize,proto3" json:"preferred_batch_size,omitempty"`
	// Preferred compression
	PreferredCompression CompressionType `protobuf:"varint,3,opt,name=preferred_compression,json=preferredCompression,proto3,enum=tapio.collector.v1.CompressionType" json:"preferred_compression,omitempty"`
	// Event filtering rules requested
	EventFilters []string `protobuf:"bytes,4,rep,name=event_filters,json=eventFilters,proto3" json:"event_filters,omitempty"`
	// Quality settings
	Quality       *QualitySettings `protobuf:"bytes,5,opt,name=quality,proto3" json:"quality,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConfigurationRequest) Reset() {
	*x = ConfigurationRequest{}
	mi := &file_proto_collector_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConfigurationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConfigurationRequest) ProtoMessage() {}

func (x *ConfigurationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConfigurationRequest.ProtoReflect.Descriptor instead.
func (*ConfigurationRequest) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{22}
}

func (x *ConfigurationRequest) GetPreferredRate() uint32 {
	if x != nil {
		return x.PreferredRate
	}
	return 0
}

func (x *ConfigurationRequest) GetPreferredBatchSize() uint32 {
	if x != nil {
		return x.PreferredBatchSize
	}
	return 0
}

func (x *ConfigurationRequest) GetPreferredCompression() CompressionType {
	if x != nil {
		return x.PreferredCompression
	}
	return CompressionType_COMPRESSION_NONE
}

func (x *ConfigurationRequest) GetEventFilters() []string {
	if x != nil {
		return x.EventFilters
	}
	return nil
}

func (x *ConfigurationRequest) GetQuality() *QualitySettings {
	if x != nil {
		return x.Quality
	}
	return nil
}

// QualitySettings configures quality requirements
type QualitySettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Minimum confidence threshold
	MinConfidence float32 `protobuf:"fixed32,1,opt,name=min_confidence,json=minConfidence,proto3" json:"min_confidence,omitempty"`
	// Required context completeness
	RequiredContext float32 `protobuf:"fixed32,2,opt,name=required_context,json=requiredContext,proto3" json:"required_context,omitempty"`
	// Maximum acceptable latency
	MaxLatency    *durationpb.Duration `protobuf:"bytes,3,opt,name=max_latency,json=maxLatency,proto3" json:"max_latency,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QualitySettings) Reset() {
	*x = QualitySettings{}
	mi := &file_proto_collector_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QualitySettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QualitySettings) ProtoMessage() {}

func (x *QualitySettings) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QualitySettings.ProtoReflect.Descriptor instead.
func (*QualitySettings) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{23}
}

func (x *QualitySettings) GetMinConfidence() float32 {
	if x != nil {
		return x.MinConfidence
	}
	return 0
}

func (x *QualitySettings) GetRequiredContext() float32 {
	if x != nil {
		return x.RequiredContext
	}
	return 0
}

func (x *QualitySettings) GetMaxLatency() *durationpb.Duration {
	if x != nil {
		return x.MaxLatency
	}
	return nil
}

// CollectorConfig provides configuration from server to collector
type CollectorConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Assigned collector ID (may differ from requested)
	CollectorId string `protobuf:"bytes,1,opt,name=collector_id,json=collectorId,proto3" json:"collector_id,omitempty"`
	// Configuration version
	ConfigVersion string `protobuf:"bytes,2,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	// Flow control settings
	FlowControl *FlowControlDirective `protobuf:"bytes,3,opt,name=flow_control,json=flowControl,proto3" json:"flow_control,omitempty"`
	// Event routing configuration
	Routing *RoutingConfig `protobuf:"bytes,4,opt,name=routing,proto3" json:"routing,omitempty"`
	// Quality requirements
	Quality *QualitySettings `protobuf:"bytes,5,opt,name=quality,proto3" json:"quality,omitempty"`
	// Server endpoints for load balancing
	Endpoints []*ServerEndpoint `protobuf:"bytes,6,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	// Heartbeat interval
	HeartbeatInterval *durationpb.Duration `protobuf:"bytes,7,opt,name=heartbeat_interval,json=heartbeatInterval,proto3" json:"heartbeat_interval,omitempty"`
	// Configuration TTL
	ConfigTtl     *durationpb.Duration `protobuf:"bytes,8,opt,name=config_ttl,json=configTtl,proto3" json:"config_ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CollectorConfig) Reset() {
	*x = CollectorConfig{}
	mi := &file_proto_collector_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CollectorConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectorConfig) ProtoMessage() {}

func (x *CollectorConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CollectorConfig.ProtoReflect.Descriptor instead.
func (*CollectorConfig) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{24}
}

func (x *CollectorConfig) GetCollectorId() string {
	if x != nil {
		return x.CollectorId
	}
	return ""
}

func (x *CollectorConfig) GetConfigVersion() string {
	if x != nil {
		return x.ConfigVersion
	}
	return ""
}

func (x *CollectorConfig) GetFlowControl() *FlowControlDirective {
	if x != nil {
		return x.FlowControl
	}
	return nil
}

func (x *CollectorConfig) GetRouting() *RoutingConfig {
	if x != nil {
		return x.Routing
	}
	return nil
}

func (x *CollectorConfig) GetQuality() *QualitySettings {
	if x != nil {
		return x.Quality
	}
	return nil
}

func (x *CollectorConfig) GetEndpoints() []*ServerEndpoint {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

func (x *CollectorConfig) GetHeartbeatInterval() *durationpb.Duration {
	if x != nil {
		return x.HeartbeatInterval
	}
	return nil
}

func (x *CollectorConfig) GetConfigTtl() *durationpb.Duration {
	if x != nil {
		return x.ConfigTtl
	}
	return nil
}

// RoutingConfig specifies how events should be routed
type RoutingConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Default route for events
	DefaultRoute string `protobuf:"bytes,1,opt,name=default_route,json=defaultRoute,proto3" json:"default_route,omitempty"`
	// Event type specific routing
	TypeRoutes map[string]string `protobuf:"bytes,2,rep,name=type_routes,json=typeRoutes,proto3" json:"type_routes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Priority routing for high-priority events
	PriorityRoute string `protobuf:"bytes,3,opt,name=priority_route,json=priorityRoute,proto3" json:"priority_route,omitempty"`
	// Load balancing strategy
	Strategy      LoadBalancingStrategy `protobuf:"varint,4,opt,name=strategy,proto3,enum=tapio.collector.v1.LoadBalancingStrategy" json:"strategy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoutingConfig) Reset() {
	*x = RoutingConfig{}
	mi := &file_proto_collector_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoutingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutingConfig) ProtoMessage() {}

func (x *RoutingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutingConfig.ProtoReflect.Descriptor instead.
func (*RoutingConfig) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{25}
}

func (x *RoutingConfig) GetDefaultRoute() string {
	if x != nil {
		return x.DefaultRoute
	}
	return ""
}

func (x *RoutingConfig) GetTypeRoutes() map[string]string {
	if x != nil {
		return x.TypeRoutes
	}
	return nil
}

func (x *RoutingConfig) GetPriorityRoute() string {
	if x != nil {
		return x.PriorityRoute
	}
	return ""
}

func (x *RoutingConfig) GetStrategy() LoadBalancingStrategy {
	if x != nil {
		return x.Strategy
	}
	return LoadBalancingStrategy_LOAD_BALANCING_ROUND_ROBIN
}

// ServerEndpoint provides server connection information
type ServerEndpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Port          uint32                 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	TlsEnabled    bool                   `protobuf:"varint,3,opt,name=tls_enabled,json=tlsEnabled,proto3" json:"tls_enabled,omitempty"`
	Region        string                 `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	Weight        uint32                 `protobuf:"varint,5,opt,name=weight,proto3" json:"weight,omitempty"`
	Health        HealthStatus           `protobuf:"varint,6,opt,name=health,proto3,enum=tapio.collector.v1.HealthStatus" json:"health,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerEndpoint) Reset() {
	*x = ServerEndpoint{}
	mi := &file_proto_collector_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerEndpoint) ProtoMessage() {}

func (x *ServerEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerEndpoint.ProtoReflect.Descriptor instead.
func (*ServerEndpoint) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{26}
}

func (x *ServerEndpoint) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *ServerEndpoint) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *ServerEndpoint) GetTlsEnabled() bool {
	if x != nil {
		return x.TlsEnabled
	}
	return false
}

func (x *ServerEndpoint) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *ServerEndpoint) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

func (x *ServerEndpoint) GetHealth() HealthStatus {
	if x != nil {
		return x.Health
	}
	return HealthStatus_HEALTH_UNKNOWN
}

// HeartbeatRequest maintains connection health
type HeartbeatRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CollectorId   string                 `protobuf:"bytes,1,opt,name=collector_id,json=collectorId,proto3" json:"collector_id,omitempty"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Status        *CollectorStatus       `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	ConfigVersion string                 `protobuf:"bytes,4,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatRequest) Reset() {
	*x = HeartbeatRequest{}
	mi := &file_proto_collector_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatRequest) ProtoMessage() {}

func (x *HeartbeatRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatRequest.ProtoReflect.Descriptor instead.
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{27}
}

func (x *HeartbeatRequest) GetCollectorId() string {
	if x != nil {
		return x.CollectorId
	}
	return ""
}

func (x *HeartbeatRequest) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *HeartbeatRequest) GetStatus() *CollectorStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *HeartbeatRequest) GetConfigVersion() string {
	if x != nil {
		return x.ConfigVersion
	}
	return ""
}

// HeartbeatResponse provides heartbeat acknowledgment and updates
type HeartbeatResponse struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	Timestamp             *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ServerStatus          *ServerStatus          `protobuf:"bytes,2,opt,name=server_status,json=serverStatus,proto3" json:"server_status,omitempty"`
	ConfigVersion         string                 `protobuf:"bytes,3,opt,name=config_version,json=configVersion,proto3" json:"config_version,omitempty"`
	ConfigUpdateAvailable bool                   `protobuf:"varint,4,opt,name=config_update_available,json=configUpdateAvailable,proto3" json:"config_update_available,omitempty"`
	FlowControl           *FlowControlDirective  `protobuf:"bytes,5,opt,name=flow_control,json=flowControl,proto3" json:"flow_control,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *HeartbeatResponse) Reset() {
	*x = HeartbeatResponse{}
	mi := &file_proto_collector_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatResponse) ProtoMessage() {}

func (x *HeartbeatResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatResponse.ProtoReflect.Descriptor instead.
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{28}
}

func (x *HeartbeatResponse) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *HeartbeatResponse) GetServerStatus() *ServerStatus {
	if x != nil {
		return x.ServerStatus
	}
	return nil
}

func (x *HeartbeatResponse) GetConfigVersion() string {
	if x != nil {
		return x.ConfigVersion
	}
	return ""
}

func (x *HeartbeatResponse) GetConfigUpdateAvailable() bool {
	if x != nil {
		return x.ConfigUpdateAvailable
	}
	return false
}

func (x *HeartbeatResponse) GetFlowControl() *FlowControlDirective {
	if x != nil {
		return x.FlowControl
	}
	return nil
}

// ServerInfoRequest requests server information
type ServerInfoRequest struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	ClientVersion     string                 `protobuf:"bytes,1,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	SupportedFeatures []string               `protobuf:"bytes,2,rep,name=supported_features,json=supportedFeatures,proto3" json:"supported_features,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ServerInfoRequest) Reset() {
	*x = ServerInfoRequest{}
	mi := &file_proto_collector_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerInfoRequest) ProtoMessage() {}

func (x *ServerInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerInfoRequest.ProtoReflect.Descriptor instead.
func (*ServerInfoRequest) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{29}
}

func (x *ServerInfoRequest) GetClientVersion() string {
	if x != nil {
		return x.ClientVersion
	}
	return ""
}

func (x *ServerInfoRequest) GetSupportedFeatures() []string {
	if x != nil {
		return x.SupportedFeatures
	}
	return nil
}

// ServerInfoResponse provides server capabilities
type ServerInfoResponse struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	ServerVersion        string                 `protobuf:"bytes,1,opt,name=server_version,json=serverVersion,proto3" json:"server_version,omitempty"`
	SupportedFeatures    []string               `protobuf:"bytes,2,rep,name=supported_features,json=supportedFeatures,proto3" json:"supported_features,omitempty"`
	Capabilities         *ServerCapabilities    `protobuf:"bytes,3,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	SupportedCompression []CompressionType      `protobuf:"varint,4,rep,packed,name=supported_compression,json=supportedCompression,proto3,enum=tapio.collector.v1.CompressionType" json:"supported_compression,omitempty"`
	RateLimits           *RateLimitInfo         `protobuf:"bytes,5,opt,name=rate_limits,json=rateLimits,proto3" json:"rate_limits,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ServerInfoResponse) Reset() {
	*x = ServerInfoResponse{}
	mi := &file_proto_collector_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerInfoResponse) ProtoMessage() {}

func (x *ServerInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerInfoResponse.ProtoReflect.Descriptor instead.
func (*ServerInfoResponse) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{30}
}

func (x *ServerInfoResponse) GetServerVersion() string {
	if x != nil {
		return x.ServerVersion
	}
	return ""
}

func (x *ServerInfoResponse) GetSupportedFeatures() []string {
	if x != nil {
		return x.SupportedFeatures
	}
	return nil
}

func (x *ServerInfoResponse) GetCapabilities() *ServerCapabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *ServerInfoResponse) GetSupportedCompression() []CompressionType {
	if x != nil {
		return x.SupportedCompression
	}
	return nil
}

func (x *ServerInfoResponse) GetRateLimits() *RateLimitInfo {
	if x != nil {
		return x.RateLimits
	}
	return nil
}

// ServerCapabilities describes server features
type ServerCapabilities struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	MaxEventsPerSecond      uint64                 `protobuf:"varint,1,opt,name=max_events_per_second,json=maxEventsPerSecond,proto3" json:"max_events_per_second,omitempty"`
	MaxConcurrentCollectors uint32                 `protobuf:"varint,2,opt,name=max_concurrent_collectors,json=maxConcurrentCollectors,proto3" json:"max_concurrent_collectors,omitempty"`
	MaxBatchSize            uint32                 `protobuf:"varint,3,opt,name=max_batch_size,json=maxBatchSize,proto3" json:"max_batch_size,omitempty"`
	SupportsStreaming       bool                   `protobuf:"varint,4,opt,name=supports_streaming,json=supportsStreaming,proto3" json:"supports_streaming,omitempty"`
	SupportsCompression     bool                   `protobuf:"varint,5,opt,name=supports_compression,json=supportsCompression,proto3" json:"supports_compression,omitempty"`
	SupportsLoadBalancing   bool                   `protobuf:"varint,6,opt,name=supports_load_balancing,json=supportsLoadBalancing,proto3" json:"supports_load_balancing,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ServerCapabilities) Reset() {
	*x = ServerCapabilities{}
	mi := &file_proto_collector_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerCapabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerCapabilities) ProtoMessage() {}

func (x *ServerCapabilities) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerCapabilities.ProtoReflect.Descriptor instead.
func (*ServerCapabilities) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{31}
}

func (x *ServerCapabilities) GetMaxEventsPerSecond() uint64 {
	if x != nil {
		return x.MaxEventsPerSecond
	}
	return 0
}

func (x *ServerCapabilities) GetMaxConcurrentCollectors() uint32 {
	if x != nil {
		return x.MaxConcurrentCollectors
	}
	return 0
}

func (x *ServerCapabilities) GetMaxBatchSize() uint32 {
	if x != nil {
		return x.MaxBatchSize
	}
	return 0
}

func (x *ServerCapabilities) GetSupportsStreaming() bool {
	if x != nil {
		return x.SupportsStreaming
	}
	return false
}

func (x *ServerCapabilities) GetSupportsCompression() bool {
	if x != nil {
		return x.SupportsCompression
	}
	return false
}

func (x *ServerCapabilities) GetSupportsLoadBalancing() bool {
	if x != nil {
		return x.SupportsLoadBalancing
	}
	return false
}

// RateLimitInfo provides rate limiting information
type RateLimitInfo struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	GlobalLimit       uint32                 `protobuf:"varint,1,opt,name=global_limit,json=globalLimit,proto3" json:"global_limit,omitempty"`
	PerCollectorLimit uint32                 `protobuf:"varint,2,opt,name=per_collector_limit,json=perCollectorLimit,proto3" json:"per_collector_limit,omitempty"`
	BurstLimit        uint32                 `protobuf:"varint,3,opt,name=burst_limit,json=burstLimit,proto3" json:"burst_limit,omitempty"`
	Window            *durationpb.Duration   `protobuf:"bytes,4,opt,name=window,proto3" json:"window,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RateLimitInfo) Reset() {
	*x = RateLimitInfo{}
	mi := &file_proto_collector_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitInfo) ProtoMessage() {}

func (x *RateLimitInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitInfo.ProtoReflect.Descriptor instead.
func (*RateLimitInfo) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{32}
}

func (x *RateLimitInfo) GetGlobalLimit() uint32 {
	if x != nil {
		return x.GlobalLimit
	}
	return 0
}

func (x *RateLimitInfo) GetPerCollectorLimit() uint32 {
	if x != nil {
		return x.PerCollectorLimit
	}
	return 0
}

func (x *RateLimitInfo) GetBurstLimit() uint32 {
	if x != nil {
		return x.BurstLimit
	}
	return 0
}

func (x *RateLimitInfo) GetWindow() *durationpb.Duration {
	if x != nil {
		return x.Window
	}
	return nil
}

// RegionInfo provides regional routing information
type RegionInfo struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Region         string                 `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
	Endpoints      []*ServerEndpoint      `protobuf:"bytes,2,rep,name=endpoints,proto3" json:"endpoints,omitempty"`
	LoadFactor     float32                `protobuf:"fixed32,3,opt,name=load_factor,json=loadFactor,proto3" json:"load_factor,omitempty"`
	CollectorCount uint32                 `protobuf:"varint,4,opt,name=collector_count,json=collectorCount,proto3" json:"collector_count,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *RegionInfo) Reset() {
	*x = RegionInfo{}
	mi := &file_proto_collector_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegionInfo) ProtoMessage() {}

func (x *RegionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegionInfo.ProtoReflect.Descriptor instead.
func (*RegionInfo) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{33}
}

func (x *RegionInfo) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *RegionInfo) GetEndpoints() []*ServerEndpoint {
	if x != nil {
		return x.Endpoints
	}
	return nil
}

func (x *RegionInfo) GetLoadFactor() float32 {
	if x != nil {
		return x.LoadFactor
	}
	return 0
}

func (x *RegionInfo) GetCollectorCount() uint32 {
	if x != nil {
		return x.CollectorCount
	}
	return 0
}

// AckMessage acknowledges received responses
type AckMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Sequence      uint64                 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty"`
	Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
	Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AckMessage) Reset() {
	*x = AckMessage{}
	mi := &file_proto_collector_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AckMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AckMessage) ProtoMessage() {}

func (x *AckMessage) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AckMessage.ProtoReflect.Descriptor instead.
func (*AckMessage) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{34}
}

func (x *AckMessage) GetSequence() uint64 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *AckMessage) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AckMessage) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ErrorResponse provides detailed error information
type ErrorResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ErrorCode              `protobuf:"varint,1,opt,name=code,proto3,enum=tapio.collector.v1.ErrorCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Details       string                 `protobuf:"bytes,3,opt,name=details,proto3" json:"details,omitempty"`
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Retryable     bool                   `protobuf:"varint,5,opt,name=retryable,proto3" json:"retryable,omitempty"`
	RetryAfter    *durationpb.Duration   `protobuf:"bytes,6,opt,name=retry_after,json=retryAfter,proto3" json:"retry_after,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ErrorResponse) Reset() {
	*x = ErrorResponse{}
	mi := &file_proto_collector_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErrorResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErrorResponse) ProtoMessage() {}

func (x *ErrorResponse) ProtoReflect() protoreflect.Message {
	mi := &file_proto_collector_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ErrorResponse.ProtoReflect.Descriptor instead.
func (*ErrorResponse) Descriptor() ([]byte, []int) {
	return file_proto_collector_proto_rawDescGZIP(), []int{35}
}

func (x *ErrorResponse) GetCode() ErrorCode {
	if x != nil {
		return x.Code
	}
	return ErrorCode_ERROR_UNKNOWN
}

func (x *ErrorResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ErrorResponse) GetDetails() string {
	if x != nil {
		return x.Details
	}
	return ""
}

func (x *ErrorResponse) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *ErrorResponse) GetRetryable() bool {
	if x != nil {
		return x.Retryable
	}
	return false
}

func (x *ErrorResponse) GetRetryAfter() *durationpb.Duration {
	if x != nil {
		return x.RetryAfter
	}
	return nil
}

var File_proto_collector_proto protoreflect.FileDescriptor

const file_proto_collector_proto_rawDesc = "" +
	"\n" +
	"\x15proto/collector.proto\x12\x12tapio.collector.v1\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x12proto/events.proto\"\xd3\x02\n" +
	"\rStreamRequest\x12\x1a\n" +
	"\bsequence\x18\x01 \x01(\x04R\bsequence\x12!\n" +
	"\fcollector_id\x18\x02 \x01(\tR\vcollectorId\x128\n" +
	"\x06events\x18\n" +
	" \x01(\v2\x1e.tapio.collector.v1.EventBatchH\x00R\x06events\x12K\n" +
	"\fflow_control\x18\v \x01(\v2&.tapio.collector.v1.FlowControlMessageH\x00R\vflowControl\x12=\n" +
	"\x06status\x18\f \x01(\v2#.tapio.collector.v1.CollectorStatusH\x00R\x06status\x122\n" +
	"\x03ack\x18\r \x01(\v2\x1e.tapio.collector.v1.AckMessageH\x00R\x03ackB\t\n" +
	"\apayload\"\x81\x03\n" +
	"\x0eStreamResponse\x12\x1a\n" +
	"\bsequence\x18\x01 \x01(\x04R\bsequence\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12;\n" +
	"\tevent_ack\x18\n" +
	" \x01(\v2\x1c.tapio.collector.v1.EventAckH\x00R\beventAck\x12M\n" +
	"\fflow_control\x18\v \x01(\v2(.tapio.collector.v1.FlowControlDirectiveH\x00R\vflowControl\x12G\n" +
	"\rserver_status\x18\f \x01(\v2 .tapio.collector.v1.ServerStatusH\x00R\fserverStatus\x129\n" +
	"\x05error\x18\r \x01(\v2!.tapio.collector.v1.ErrorResponseH\x00R\x05errorB\t\n" +
	"\apayload\"\xc0\x03\n" +
	"\n" +
	"EventBatch\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x129\n" +
	"\n" +
	"created_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12!\n" +
	"\fcollector_id\x18\x03 \x01(\tR\vcollectorId\x12%\n" +
	"\x0ecollector_type\x18\x04 \x01(\tR\rcollectorType\x12\x17\n" +
	"\anode_id\x18\x05 \x01(\tR\x06nodeId\x125\n" +
	"\x06events\x18\x06 \x03(\v2\x1d.tapio.events.v1.UnifiedEventR\x06events\x12=\n" +
	"\bmetadata\x18\a \x01(\v2!.tapio.collector.v1.BatchMetadataR\bmetadata\x12E\n" +
	"\vcompression\x18\b \x01(\x0e2#.tapio.collector.v1.CompressionTypeR\vcompression\x12<\n" +
	"\aquality\x18\t \x01(\v2\".tapio.collector.v1.QualityMetricsR\aquality\"\x81\x02\n" +
	"\rBatchMetadata\x12+\n" +
	"\x11uncompressed_size\x18\x01 \x01(\x04R\x10uncompressedSize\x12'\n" +
	"\x0fcompressed_size\x18\x02 \x01(\x04R\x0ecompressedSize\x12\x1f\n" +
	"\vevent_count\x18\x03 \x01(\rR\n" +
	"eventCount\x126\n" +
	"\ttime_span\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\btimeSpan\x12%\n" +
	"\x0edropped_events\x18\x05 \x01(\rR\rdroppedEvents\x12\x1a\n" +
	"\bchecksum\x18\x06 \x01(\tR\bchecksum\"\xcd\x02\n" +
	"\x0eQualityMetrics\x12%\n" +
	"\x0eavg_confidence\x18\x01 \x01(\x02R\ravgConfidence\x121\n" +
	"\x14context_completeness\x18\x02 \x01(\x02R\x13contextCompleteness\x12O\n" +
	"\x12processing_latency\x18\x03 \x01(\v2 .tapio.collector.v1.LatencyStatsR\x11processingLatency\x12O\n" +
	"\x12collection_latency\x18\x04 \x01(\v2 .tapio.collector.v1.LatencyStatsR\x11collectionLatency\x12?\n" +
	"\verror_stats\x18\x05 \x01(\v2\x1e.tapio.collector.v1.ErrorStatsR\n" +
	"errorStats\"\x9c\x02\n" +
	"\fLatencyStats\x12+\n" +
	"\x03min\x18\x01 \x01(\v2\x19.google.protobuf.DurationR\x03min\x12+\n" +
	"\x03max\x18\x02 \x01(\v2\x19.google.protobuf.DurationR\x03max\x12+\n" +
	"\x03avg\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\x03avg\x12+\n" +
	"\x03p50\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x03p50\x12+\n" +
	"\x03p95\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x03p95\x12+\n" +
	"\x03p99\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x03p99\"\xd5\x01\n" +
	"\n" +
	"ErrorStats\x12!\n" +
	"\ftotal_errors\x18\x01 \x01(\rR\vtotalErrors\x12+\n" +
	"\x11validation_errors\x18\x02 \x01(\rR\x10validationErrors\x121\n" +
	"\x14serialization_errors\x18\x03 \x01(\rR\x13serializationErrors\x12%\n" +
	"\x0enetwork_errors\x18\x04 \x01(\rR\rnetworkErrors\x12\x1d\n" +
	"\n" +
	"error_rate\x18\x05 \x01(\x02R\terrorRate\"\xcf\x01\n" +
	"\x12FlowControlMessage\x12%\n" +
	"\x0erequested_rate\x18\x01 \x01(\rR\rrequestedRate\x12-\n" +
	"\x12buffer_utilization\x18\x02 \x01(\x02R\x11bufferUtilization\x12K\n" +
	"\x0fmemory_pressure\x18\x03 \x01(\x0e2\".tapio.collector.v1.MemoryPressureR\x0ememoryPressure\x12\x16\n" +
	"\x06reason\x18\x04 \x01(\tR\x06reason\"\xf2\x02\n" +
	"\x14FlowControlDirective\x121\n" +
	"\x15max_events_per_second\x18\x01 \x01(\rR\x12maxEventsPerSecond\x12$\n" +
	"\x0emax_batch_size\x18\x02 \x01(\rR\fmaxBatchSize\x12@\n" +
	"\x0ebatch_interval\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\rbatchInterval\x12-\n" +
	"\x12enable_compression\x18\x04 \x01(\bR\x11enableCompression\x12N\n" +
	"\x10compression_type\x18\x05 \x01(\x0e2#.tapio.collector.v1.CompressionTypeR\x0fcompressionType\x12@\n" +
	"\x0evalid_duration\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\rvalidDuration\"\xc9\x02\n" +
	"\bEventAck\x12\x19\n" +
	"\bbatch_id\x18\x01 \x01(\tR\abatchId\x12)\n" +
	"\x10request_sequence\x18\x02 \x01(\x04R\x0frequestSequence\x12'\n" +
	"\x0fprocessed_count\x18\x03 \x01(\rR\x0eprocessedCount\x12!\n" +
	"\ffailed_count\x18\x04 \x01(\rR\vfailedCount\x12(\n" +
	"\x10failed_event_ids\x18\x05 \x03(\tR\x0efailedEventIds\x12B\n" +
	"\x0fprocessing_time\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\x0eprocessingTime\x12=\n" +
	"\fprocessed_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\vprocessedAt\"\xc3\x02\n" +
	"\x0fCollectorStatus\x128\n" +
	"\x05state\x18\x01 \x01(\x0e2\".tapio.collector.v1.CollectorStateR\x05state\x12E\n" +
	"\tresources\x18\x02 \x01(\v2'.tapio.collector.v1.ResourceUtilizationR\tresources\x129\n" +
	"\x05stats\x18\x03 \x01(\v2#.tapio.collector.v1.CollectionStatsR\x05stats\x12%\n" +
	"\x0econfig_version\x18\x04 \x01(\tR\rconfigVersion\x121\n" +
	"\x06uptime\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x06uptime\x12\x1a\n" +
	"\bwarnings\x18\x06 \x03(\tR\bwarnings\"\xa9\x02\n" +
	"\fServerStatus\x12\x12\n" +
	"\x04load\x18\x01 \x01(\x02R\x04load\x12-\n" +
	"\x12available_capacity\x18\x02 \x01(\rR\x11availableCapacity\x121\n" +
	"\x14connected_collectors\x18\x03 \x01(\rR\x13connectedCollectors\x12%\n" +
	"\x0econfig_version\x18\x04 \x01(\tR\rconfigVersion\x12B\n" +
	"\vrate_limits\x18\x05 \x01(\v2!.tapio.collector.v1.RateLimitInfoR\n" +
	"rateLimits\x128\n" +
	"\aregions\x18\x06 \x03(\v2\x1e.tapio.collector.v1.RegionInfoR\aregions\"\xf3\x01\n" +
	"\x13ResourceUtilization\x12\x1b\n" +
	"\tcpu_usage\x18\x01 \x01(\x02R\bcpuUsage\x12!\n" +
	"\fmemory_bytes\x18\x02 \x01(\x04R\vmemoryBytes\x12!\n" +
	"\fmemory_limit\x18\x03 \x01(\x04R\vmemoryLimit\x12@\n" +
	"\anetwork\x18\x04 \x01(\v2&.tapio.collector.v1.NetworkUtilizationR\anetwork\x127\n" +
	"\x04disk\x18\x05 \x01(\v2#.tapio.collector.v1.DiskUtilizationR\x04disk\"\xcd\x01\n" +
	"\x12NetworkUtilization\x12+\n" +
	"\x12bytes_sent_per_sec\x18\x01 \x01(\x04R\x0fbytesSentPerSec\x123\n" +
	"\x16bytes_received_per_sec\x18\x02 \x01(\x04R\x13bytesReceivedPerSec\x12 \n" +
	"\vconnections\x18\x03 \x01(\rR\vconnections\x123\n" +
	"\alatency\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\alatency\"\xbb\x01\n" +
	"\x0fDiskUtilization\x12\"\n" +
	"\rreads_per_sec\x18\x01 \x01(\x04R\vreadsPerSec\x12$\n" +
	"\x0ewrites_per_sec\x18\x02 \x01(\x04R\fwritesPerSec\x12+\n" +
	"\x12bytes_read_per_sec\x18\x03 \x01(\x04R\x0fbytesReadPerSec\x121\n" +
	"\x15bytes_written_per_sec\x18\x04 \x01(\x04R\x12bytesWrittenPerSec\"\xaf\x02\n" +
	"\x0fCollectionStats\x12!\n" +
	"\ftotal_events\x18\x01 \x01(\x04R\vtotalEvents\x12*\n" +
	"\x11events_per_second\x18\x02 \x01(\x02R\x0feventsPerSecond\x12\x1f\n" +
	"\vtotal_bytes\x18\x03 \x01(\x04R\n" +
	"totalBytes\x12(\n" +
	"\x10bytes_per_second\x18\x04 \x01(\x02R\x0ebytesPerSecond\x12!\n" +
	"\fbatches_sent\x18\x05 \x01(\x04R\vbatchesSent\x12$\n" +
	"\x0eavg_batch_size\x18\x06 \x01(\x02R\favgBatchSize\x129\n" +
	"\x06errors\x18\a \x01(\v2!.tapio.collector.v1.ErrorCountersR\x06errors\"\xef\x01\n" +
	"\rErrorCounters\x12+\n" +
	"\x11collection_errors\x18\x01 \x01(\x04R\x10collectionErrors\x121\n" +
	"\x14serialization_errors\x18\x02 \x01(\x04R\x13serializationErrors\x12%\n" +
	"\x0enetwork_errors\x18\x03 \x01(\x04R\rnetworkErrors\x12+\n" +
	"\x11validation_errors\x18\x04 \x01(\x04R\x10validationErrors\x12*\n" +
	"\x11rate_limit_errors\x18\x05 \x01(\x04R\x0frateLimitErrors\"\x9f\x01\n" +
	"\x11EventBatchRequest\x124\n" +
	"\x05batch\x18\x01 \x01(\v2\x1e.tapio.collector.v1.EventBatchR\x05batch\x12\x1f\n" +
	"\vrequire_ack\x18\x02 \x01(\bR\n" +
	"requireAck\x123\n" +
	"\atimeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\atimeout\"\xc5\x01\n" +
	"\x12EventBatchResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12.\n" +
	"\x03ack\x18\x03 \x01(\v2\x1c.tapio.collector.v1.EventAckR\x03ack\x12K\n" +
	"\fflow_control\x18\x04 \x01(\v2(.tapio.collector.v1.FlowControlDirectiveR\vflowControl\"\xcd\x02\n" +
	"\x15CollectorRegistration\x12!\n" +
	"\fcollector_id\x18\x01 \x01(\tR\vcollectorId\x12%\n" +
	"\x0ecollector_type\x18\x02 \x01(\tR\rcollectorType\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x120\n" +
	"\x04node\x18\x04 \x01(\v2\x1c.tapio.collector.v1.NodeInfoR\x04node\x12M\n" +
	"\fcapabilities\x18\x05 \x01(\v2).tapio.collector.v1.CollectorCapabilitiesR\fcapabilities\x12O\n" +
	"\x0econfig_request\x18\x06 \x01(\v2(.tapio.collector.v1.ConfigurationRequestR\rconfigRequest\"\xc3\x02\n" +
	"\bNodeInfo\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x1a\n" +
	"\bhostname\x18\x02 \x01(\tR\bhostname\x12\x0e\n" +
	"\x02os\x18\x03 \x01(\tR\x02os\x12\"\n" +
	"\farchitecture\x18\x04 \x01(\tR\farchitecture\x12%\n" +
	"\x0ekernel_version\x18\x05 \x01(\tR\rkernelVersion\x12\x16\n" +
	"\x06region\x18\x06 \x01(\tR\x06region\x12\x12\n" +
	"\x04zone\x18\a \x01(\tR\x04zone\x12@\n" +
	"\x06labels\x18\b \x03(\v2(.tapio.collector.v1.NodeInfo.LabelsEntryR\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xfb\x02\n" +
	"\x15CollectorCapabilities\x121\n" +
	"\x15max_events_per_second\x18\x01 \x01(\rR\x12maxEventsPerSecond\x12X\n" +
	"\x15supported_compression\x18\x02 \x03(\x0e2#.tapio.collector.v1.CompressionTypeR\x14supportedCompression\x122\n" +
	"\x15supported_event_types\x18\x03 \x03(\tR\x13supportedEventTypes\x12-\n" +
	"\x12supports_streaming\x18\x04 \x01(\bR\x11supportsStreaming\x12+\n" +
	"\x11supports_batching\x18\x05 \x01(\bR\x10supportsBatching\x12$\n" +
	"\x0emax_batch_size\x18\x06 \x01(\rR\fmaxBatchSize\x12\x1f\n" +
	"\vbuffer_size\x18\a \x01(\x04R\n" +
	"bufferSize\"\xad\x02\n" +
	"\x14ConfigurationRequest\x12%\n" +
	"\x0epreferred_rate\x18\x01 \x01(\rR\rpreferredRate\x120\n" +
	"\x14preferred_batch_size\x18\x02 \x01(\rR\x12preferredBatchSize\x12X\n" +
	"\x15preferred_compression\x18\x03 \x01(\x0e2#.tapio.collector.v1.CompressionTypeR\x14preferredCompression\x12#\n" +
	"\revent_filters\x18\x04 \x03(\tR\feventFilters\x12=\n" +
	"\aquality\x18\x05 \x01(\v2#.tapio.collector.v1.QualitySettingsR\aquality\"\x9f\x01\n" +
	"\x0fQualitySettings\x12%\n" +
	"\x0emin_confidence\x18\x01 \x01(\x02R\rminConfidence\x12)\n" +
	"\x10required_context\x18\x02 \x01(\x02R\x0frequiredContext\x12:\n" +
	"\vmax_latency\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"maxLatency\"\xea\x03\n" +
	"\x0fCollectorConfig\x12!\n" +
	"\fcollector_id\x18\x01 \x01(\tR\vcollectorId\x12%\n" +
	"\x0econfig_version\x18\x02 \x01(\tR\rconfigVersion\x12K\n" +
	"\fflow_control\x18\x03 \x01(\v2(.tapio.collector.v1.FlowControlDirectiveR\vflowControl\x12;\n" +
	"\arouting\x18\x04 \x01(\v2!.tapio.collector.v1.RoutingConfigR\arouting\x12=\n" +
	"\aquality\x18\x05 \x01(\v2#.tapio.collector.v1.QualitySettingsR\aquality\x12@\n" +
	"\tendpoints\x18\x06 \x03(\v2\".tapio.collector.v1.ServerEndpointR\tendpoints\x12H\n" +
	"\x12heartbeat_interval\x18\a \x01(\v2\x19.google.protobuf.DurationR\x11heartbeatInterval\x128\n" +
	"\n" +
	"config_ttl\x18\b \x01(\v2\x19.google.protobuf.DurationR\tconfigTtl\"\xb5\x02\n" +
	"\rRoutingConfig\x12#\n" +
	"\rdefault_route\x18\x01 \x01(\tR\fdefaultRoute\x12R\n" +
	"\vtype_routes\x18\x02 \x03(\v21.tapio.collector.v1.RoutingConfig.TypeRoutesEntryR\n" +
	"typeRoutes\x12%\n" +
	"\x0epriority_route\x18\x03 \x01(\tR\rpriorityRoute\x12E\n" +
	"\bstrategy\x18\x04 \x01(\x0e2).tapio.collector.v1.LoadBalancingStrategyR\bstrategy\x1a=\n" +
	"\x0fTypeRoutesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xc9\x01\n" +
	"\x0eServerEndpoint\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x12\n" +
	"\x04port\x18\x02 \x01(\rR\x04port\x12\x1f\n" +
	"\vtls_enabled\x18\x03 \x01(\bR\n" +
	"tlsEnabled\x12\x16\n" +
	"\x06region\x18\x04 \x01(\tR\x06region\x12\x16\n" +
	"\x06weight\x18\x05 \x01(\rR\x06weight\x128\n" +
	"\x06health\x18\x06 \x01(\x0e2 .tapio.collector.v1.HealthStatusR\x06health\"\xd3\x01\n" +
	"\x10HeartbeatRequest\x12!\n" +
	"\fcollector_id\x18\x01 \x01(\tR\vcollectorId\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12;\n" +
	"\x06status\x18\x03 \x01(\v2#.tapio.collector.v1.CollectorStatusR\x06status\x12%\n" +
	"\x0econfig_version\x18\x04 \x01(\tR\rconfigVersion\"\xc0\x02\n" +
	"\x11HeartbeatResponse\x128\n" +
	"\ttimestamp\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12E\n" +
	"\rserver_status\x18\x02 \x01(\v2 .tapio.collector.v1.ServerStatusR\fserverStatus\x12%\n" +
	"\x0econfig_version\x18\x03 \x01(\tR\rconfigVersion\x126\n" +
	"\x17config_update_available\x18\x04 \x01(\bR\x15configUpdateAvailable\x12K\n" +
	"\fflow_control\x18\x05 \x01(\v2(.tapio.collector.v1.FlowControlDirectiveR\vflowControl\"i\n" +
	"\x11ServerInfoRequest\x12%\n" +
	"\x0eclient_version\x18\x01 \x01(\tR\rclientVersion\x12-\n" +
	"\x12supported_features\x18\x02 \x03(\tR\x11supportedFeatures\"\xd4\x02\n" +
	"\x12ServerInfoResponse\x12%\n" +
	"\x0eserver_version\x18\x01 \x01(\tR\rserverVersion\x12-\n" +
	"\x12supported_features\x18\x02 \x03(\tR\x11supportedFeatures\x12J\n" +
	"\fcapabilities\x18\x03 \x01(\v2&.tapio.collector.v1.ServerCapabilitiesR\fcapabilities\x12X\n" +
	"\x15supported_compression\x18\x04 \x03(\x0e2#.tapio.collector.v1.CompressionTypeR\x14supportedCompression\x12B\n" +
	"\vrate_limits\x18\x05 \x01(\v2!.tapio.collector.v1.RateLimitInfoR\n" +
	"rateLimits\"\xc3\x02\n" +
	"\x12ServerCapabilities\x121\n" +
	"\x15max_events_per_second\x18\x01 \x01(\x04R\x12maxEventsPerSecond\x12:\n" +
	"\x19max_concurrent_collectors\x18\x02 \x01(\rR\x17maxConcurrentCollectors\x12$\n" +
	"\x0emax_batch_size\x18\x03 \x01(\rR\fmaxBatchSize\x12-\n" +
	"\x12supports_streaming\x18\x04 \x01(\bR\x11supportsStreaming\x121\n" +
	"\x14supports_compression\x18\x05 \x01(\bR\x13supportsCompression\x126\n" +
	"\x17supports_load_balancing\x18\x06 \x01(\bR\x15supportsLoadBalancing\"\xb6\x01\n" +
	"\rRateLimitInfo\x12!\n" +
	"\fglobal_limit\x18\x01 \x01(\rR\vglobalLimit\x12.\n" +
	"\x13per_collector_limit\x18\x02 \x01(\rR\x11perCollectorLimit\x12\x1f\n" +
	"\vburst_limit\x18\x03 \x01(\rR\n" +
	"burstLimit\x121\n" +
	"\x06window\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\x06window\"\xb0\x01\n" +
	"\n" +
	"RegionInfo\x12\x16\n" +
	"\x06region\x18\x01 \x01(\tR\x06region\x12@\n" +
	"\tendpoints\x18\x02 \x03(\v2\".tapio.collector.v1.ServerEndpointR\tendpoints\x12\x1f\n" +
	"\vload_factor\x18\x03 \x01(\x02R\n" +
	"loadFactor\x12'\n" +
	"\x0fcollector_count\x18\x04 \x01(\rR\x0ecollectorCount\"\\\n" +
	"\n" +
	"AckMessage\x12\x1a\n" +
	"\bsequence\x18\x01 \x01(\x04R\bsequence\x12\x18\n" +
	"\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"\x8a\x02\n" +
	"\rErrorResponse\x121\n" +
	"\x04code\x18\x01 \x01(\x0e2\x1d.tapio.collector.v1.ErrorCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x18\n" +
	"\adetails\x18\x03 \x01(\tR\adetails\x128\n" +
	"\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x1c\n" +
	"\tretryable\x18\x05 \x01(\bR\tretryable\x12:\n" +
	"\vretry_after\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\n" +
	"retryAfter*\x80\x01\n" +
	"\x0fCompressionType\x12\x14\n" +
	"\x10COMPRESSION_NONE\x10\x00\x12\x14\n" +
	"\x10COMPRESSION_GZIP\x10\x01\x12\x14\n" +
	"\x10COMPRESSION_ZSTD\x10\x02\x12\x13\n" +
	"\x0fCOMPRESSION_LZ4\x10\x03\x12\x16\n" +
	"\x12COMPRESSION_SNAPPY\x10\x04*\xb2\x01\n" +
	"\x0eCollectorState\x12\x15\n" +
	"\x11COLLECTOR_UNKNOWN\x10\x00\x12\x16\n" +
	"\x12COLLECTOR_STARTING\x10\x01\x12\x15\n" +
	"\x11COLLECTOR_RUNNING\x10\x02\x12\x16\n" +
	"\x12COLLECTOR_DEGRADED\x10\x03\x12\x16\n" +
	"\x12COLLECTOR_STOPPING\x10\x04\x12\x15\n" +
	"\x11COLLECTOR_STOPPED\x10\x05\x12\x13\n" +
	"\x0fCOLLECTOR_ERROR\x10\x06*\x97\x01\n" +
	"\x0eMemoryPressure\x12\x18\n" +
	"\x14MEMORY_PRESSURE_NONE\x10\x00\x12\x17\n" +
	"\x13MEMORY_PRESSURE_LOW\x10\x01\x12\x1a\n" +
	"\x16MEMORY_PRESSURE_MEDIUM\x10\x02\x12\x18\n" +
	"\x14MEMORY_PRESSURE_HIGH\x10\x03\x12\x1c\n" +
	"\x18MEMORY_PRESSURE_CRITICAL\x10\x04*\xc1\x01\n" +
	"\x15LoadBalancingStrategy\x12\x1e\n" +
	"\x1aLOAD_BALANCING_ROUND_ROBIN\x10\x00\x12$\n" +
	" LOAD_BALANCING_LEAST_CONNECTIONS\x10\x01\x12\x1b\n" +
	"\x17LOAD_BALANCING_WEIGHTED\x10\x02\x12\"\n" +
	"\x1eLOAD_BALANCING_CONSISTENT_HASH\x10\x03\x12!\n" +
	"\x1dLOAD_BALANCING_LOCALITY_AWARE\x10\x04*y\n" +
	"\fHealthStatus\x12\x12\n" +
	"\x0eHEALTH_UNKNOWN\x10\x00\x12\x12\n" +
	"\x0eHEALTH_HEALTHY\x10\x01\x12\x13\n" +
	"\x0fHEALTH_DEGRADED\x10\x02\x12\x14\n" +
	"\x10HEALTH_UNHEALTHY\x10\x03\x12\x16\n" +
	"\x12HEALTH_MAINTENANCE\x10\x04*\xf2\x02\n" +
	"\tErrorCode\x12\x11\n" +
	"\rERROR_UNKNOWN\x10\x00\x12\x19\n" +
	"\x15ERROR_INVALID_REQUEST\x10\x01\x12\x1f\n" +
	"\x1bERROR_AUTHENTICATION_FAILED\x10\x02\x12\x1e\n" +
	"\x1aERROR_AUTHORIZATION_FAILED\x10\x03\x12\x16\n" +
	"\x12ERROR_RATE_LIMITED\x10\x04\x12\x18\n" +
	"\x14ERROR_QUOTA_EXCEEDED\x10\x05\x12\x1f\n" +
	"\x1bERROR_INVALID_CONFIGURATION\x10\x06\x12\x1d\n" +
	"\x19ERROR_SERVICE_UNAVAILABLE\x10\a\x12\x18\n" +
	"\x14ERROR_INTERNAL_ERROR\x10\b\x12\x11\n" +
	"\rERROR_TIMEOUT\x10\t\x12\x1d\n" +
	"\x19ERROR_INVALID_COMPRESSION\x10\n" +
	"\x12\x19\n" +
	"\x15ERROR_BATCH_TOO_LARGE\x10\v\x12\x1d\n" +
	"\x19ERROR_UNSUPPORTED_VERSION\x10\f2\xf1\x03\n" +
	"\x10CollectorService\x12Y\n" +
	"\fStreamEvents\x12!.tapio.collector.v1.StreamRequest\x1a\".tapio.collector.v1.StreamResponse(\x010\x01\x12_\n" +
	"\x0eSendEventBatch\x12%.tapio.collector.v1.EventBatchRequest\x1a&.tapio.collector.v1.EventBatchResponse\x12c\n" +
	"\x11RegisterCollector\x12).tapio.collector.v1.CollectorRegistration\x1a#.tapio.collector.v1.CollectorConfig\x12\\\n" +
	"\tHeartbeat\x12$.tapio.collector.v1.HeartbeatRequest\x1a%.tapio.collector.v1.HeartbeatResponse(\x010\x01\x12^\n" +
	"\rGetServerInfo\x12%.tapio.collector.v1.ServerInfoRequest\x1a&.tapio.collector.v1.ServerInfoResponseB*Z(github.com/yairfalse/tapio/pkg/grpc;grpcb\x06proto3"

var (
	file_proto_collector_proto_rawDescOnce sync.Once
	file_proto_collector_proto_rawDescData []byte
)

func file_proto_collector_proto_rawDescGZIP() []byte {
	file_proto_collector_proto_rawDescOnce.Do(func() {
		file_proto_collector_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_collector_proto_rawDesc), len(file_proto_collector_proto_rawDesc)))
	})
	return file_proto_collector_proto_rawDescData
}

var file_proto_collector_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_proto_collector_proto_msgTypes = make([]protoimpl.MessageInfo, 38)
var file_proto_collector_proto_goTypes = []any{
	(CompressionType)(0),          // 0: tapio.collector.v1.CompressionType
	(CollectorState)(0),           // 1: tapio.collector.v1.CollectorState
	(MemoryPressure)(0),           // 2: tapio.collector.v1.MemoryPressure
	(LoadBalancingStrategy)(0),    // 3: tapio.collector.v1.LoadBalancingStrategy
	(HealthStatus)(0),             // 4: tapio.collector.v1.HealthStatus
	(ErrorCode)(0),                // 5: tapio.collector.v1.ErrorCode
	(*StreamRequest)(nil),         // 6: tapio.collector.v1.StreamRequest
	(*StreamResponse)(nil),        // 7: tapio.collector.v1.StreamResponse
	(*EventBatch)(nil),            // 8: tapio.collector.v1.EventBatch
	(*BatchMetadata)(nil),         // 9: tapio.collector.v1.BatchMetadata
	(*QualityMetrics)(nil),        // 10: tapio.collector.v1.QualityMetrics
	(*LatencyStats)(nil),          // 11: tapio.collector.v1.LatencyStats
	(*ErrorStats)(nil),            // 12: tapio.collector.v1.ErrorStats
	(*FlowControlMessage)(nil),    // 13: tapio.collector.v1.FlowControlMessage
	(*FlowControlDirective)(nil),  // 14: tapio.collector.v1.FlowControlDirective
	(*EventAck)(nil),              // 15: tapio.collector.v1.EventAck
	(*CollectorStatus)(nil),       // 16: tapio.collector.v1.CollectorStatus
	(*ServerStatus)(nil),          // 17: tapio.collector.v1.ServerStatus
	(*ResourceUtilization)(nil),   // 18: tapio.collector.v1.ResourceUtilization
	(*NetworkUtilization)(nil),    // 19: tapio.collector.v1.NetworkUtilization
	(*DiskUtilization)(nil),       // 20: tapio.collector.v1.DiskUtilization
	(*CollectionStats)(nil),       // 21: tapio.collector.v1.CollectionStats
	(*ErrorCounters)(nil),         // 22: tapio.collector.v1.ErrorCounters
	(*EventBatchRequest)(nil),     // 23: tapio.collector.v1.EventBatchRequest
	(*EventBatchResponse)(nil),    // 24: tapio.collector.v1.EventBatchResponse
	(*CollectorRegistration)(nil), // 25: tapio.collector.v1.CollectorRegistration
	(*NodeInfo)(nil),              // 26: tapio.collector.v1.NodeInfo
	(*CollectorCapabilities)(nil), // 27: tapio.collector.v1.CollectorCapabilities
	(*ConfigurationRequest)(nil),  // 28: tapio.collector.v1.ConfigurationRequest
	(*QualitySettings)(nil),       // 29: tapio.collector.v1.QualitySettings
	(*CollectorConfig)(nil),       // 30: tapio.collector.v1.CollectorConfig
	(*RoutingConfig)(nil),         // 31: tapio.collector.v1.RoutingConfig
	(*ServerEndpoint)(nil),        // 32: tapio.collector.v1.ServerEndpoint
	(*HeartbeatRequest)(nil),      // 33: tapio.collector.v1.HeartbeatRequest
	(*HeartbeatResponse)(nil),     // 34: tapio.collector.v1.HeartbeatResponse
	(*ServerInfoRequest)(nil),     // 35: tapio.collector.v1.ServerInfoRequest
	(*ServerInfoResponse)(nil),    // 36: tapio.collector.v1.ServerInfoResponse
	(*ServerCapabilities)(nil),    // 37: tapio.collector.v1.ServerCapabilities
	(*RateLimitInfo)(nil),         // 38: tapio.collector.v1.RateLimitInfo
	(*RegionInfo)(nil),            // 39: tapio.collector.v1.RegionInfo
	(*AckMessage)(nil),            // 40: tapio.collector.v1.AckMessage
	(*ErrorResponse)(nil),         // 41: tapio.collector.v1.ErrorResponse
	nil,                           // 42: tapio.collector.v1.NodeInfo.LabelsEntry
	nil,                           // 43: tapio.collector.v1.RoutingConfig.TypeRoutesEntry
	(*timestamppb.Timestamp)(nil), // 44: google.protobuf.Timestamp
	(*events.UnifiedEvent)(nil),   // 45: tapio.events.v1.UnifiedEvent
	(*durationpb.Duration)(nil),   // 46: google.protobuf.Duration
}
var file_proto_collector_proto_depIdxs = []int32{
	8,  // 0: tapio.collector.v1.StreamRequest.events:type_name -> tapio.collector.v1.EventBatch
	13, // 1: tapio.collector.v1.StreamRequest.flow_control:type_name -> tapio.collector.v1.FlowControlMessage
	16, // 2: tapio.collector.v1.StreamRequest.status:type_name -> tapio.collector.v1.CollectorStatus
	40, // 3: tapio.collector.v1.StreamRequest.ack:type_name -> tapio.collector.v1.AckMessage
	44, // 4: tapio.collector.v1.StreamResponse.timestamp:type_name -> google.protobuf.Timestamp
	15, // 5: tapio.collector.v1.StreamResponse.event_ack:type_name -> tapio.collector.v1.EventAck
	14, // 6: tapio.collector.v1.StreamResponse.flow_control:type_name -> tapio.collector.v1.FlowControlDirective
	17, // 7: tapio.collector.v1.StreamResponse.server_status:type_name -> tapio.collector.v1.ServerStatus
	41, // 8: tapio.collector.v1.StreamResponse.error:type_name -> tapio.collector.v1.ErrorResponse
	44, // 9: tapio.collector.v1.EventBatch.created_at:type_name -> google.protobuf.Timestamp
	45, // 10: tapio.collector.v1.EventBatch.events:type_name -> tapio.events.v1.UnifiedEvent
	9,  // 11: tapio.collector.v1.EventBatch.metadata:type_name -> tapio.collector.v1.BatchMetadata
	0,  // 12: tapio.collector.v1.EventBatch.compression:type_name -> tapio.collector.v1.CompressionType
	10, // 13: tapio.collector.v1.EventBatch.quality:type_name -> tapio.collector.v1.QualityMetrics
	46, // 14: tapio.collector.v1.BatchMetadata.time_span:type_name -> google.protobuf.Duration
	11, // 15: tapio.collector.v1.QualityMetrics.processing_latency:type_name -> tapio.collector.v1.LatencyStats
	11, // 16: tapio.collector.v1.QualityMetrics.collection_latency:type_name -> tapio.collector.v1.LatencyStats
	12, // 17: tapio.collector.v1.QualityMetrics.error_stats:type_name -> tapio.collector.v1.ErrorStats
	46, // 18: tapio.collector.v1.LatencyStats.min:type_name -> google.protobuf.Duration
	46, // 19: tapio.collector.v1.LatencyStats.max:type_name -> google.protobuf.Duration
	46, // 20: tapio.collector.v1.LatencyStats.avg:type_name -> google.protobuf.Duration
	46, // 21: tapio.collector.v1.LatencyStats.p50:type_name -> google.protobuf.Duration
	46, // 22: tapio.collector.v1.LatencyStats.p95:type_name -> google.protobuf.Duration
	46, // 23: tapio.collector.v1.LatencyStats.p99:type_name -> google.protobuf.Duration
	2,  // 24: tapio.collector.v1.FlowControlMessage.memory_pressure:type_name -> tapio.collector.v1.MemoryPressure
	46, // 25: tapio.collector.v1.FlowControlDirective.batch_interval:type_name -> google.protobuf.Duration
	0,  // 26: tapio.collector.v1.FlowControlDirective.compression_type:type_name -> tapio.collector.v1.CompressionType
	46, // 27: tapio.collector.v1.FlowControlDirective.valid_duration:type_name -> google.protobuf.Duration
	46, // 28: tapio.collector.v1.EventAck.processing_time:type_name -> google.protobuf.Duration
	44, // 29: tapio.collector.v1.EventAck.processed_at:type_name -> google.protobuf.Timestamp
	1,  // 30: tapio.collector.v1.CollectorStatus.state:type_name -> tapio.collector.v1.CollectorState
	18, // 31: tapio.collector.v1.CollectorStatus.resources:type_name -> tapio.collector.v1.ResourceUtilization
	21, // 32: tapio.collector.v1.CollectorStatus.stats:type_name -> tapio.collector.v1.CollectionStats
	46, // 33: tapio.collector.v1.CollectorStatus.uptime:type_name -> google.protobuf.Duration
	38, // 34: tapio.collector.v1.ServerStatus.rate_limits:type_name -> tapio.collector.v1.RateLimitInfo
	39, // 35: tapio.collector.v1.ServerStatus.regions:type_name -> tapio.collector.v1.RegionInfo
	19, // 36: tapio.collector.v1.ResourceUtilization.network:type_name -> tapio.collector.v1.NetworkUtilization
	20, // 37: tapio.collector.v1.ResourceUtilization.disk:type_name -> tapio.collector.v1.DiskUtilization
	46, // 38: tapio.collector.v1.NetworkUtilization.latency:type_name -> google.protobuf.Duration
	22, // 39: tapio.collector.v1.CollectionStats.errors:type_name -> tapio.collector.v1.ErrorCounters
	8,  // 40: tapio.collector.v1.EventBatchRequest.batch:type_name -> tapio.collector.v1.EventBatch
	46, // 41: tapio.collector.v1.EventBatchRequest.timeout:type_name -> google.protobuf.Duration
	15, // 42: tapio.collector.v1.EventBatchResponse.ack:type_name -> tapio.collector.v1.EventAck
	14, // 43: tapio.collector.v1.EventBatchResponse.flow_control:type_name -> tapio.collector.v1.FlowControlDirective
	26, // 44: tapio.collector.v1.CollectorRegistration.node:type_name -> tapio.collector.v1.NodeInfo
	27, // 45: tapio.collector.v1.CollectorRegistration.capabilities:type_name -> tapio.collector.v1.CollectorCapabilities
	28, // 46: tapio.collector.v1.CollectorRegistration.config_request:type_name -> tapio.collector.v1.ConfigurationRequest
	42, // 47: tapio.collector.v1.NodeInfo.labels:type_name -> tapio.collector.v1.NodeInfo.LabelsEntry
	0,  // 48: tapio.collector.v1.CollectorCapabilities.supported_compression:type_name -> tapio.collector.v1.CompressionType
	0,  // 49: tapio.collector.v1.ConfigurationRequest.preferred_compression:type_name -> tapio.collector.v1.CompressionType
	29, // 50: tapio.collector.v1.ConfigurationRequest.quality:type_name -> tapio.collector.v1.QualitySettings
	46, // 51: tapio.collector.v1.QualitySettings.max_latency:type_name -> google.protobuf.Duration
	14, // 52: tapio.collector.v1.CollectorConfig.flow_control:type_name -> tapio.collector.v1.FlowControlDirective
	31, // 53: tapio.collector.v1.CollectorConfig.routing:type_name -> tapio.collector.v1.RoutingConfig
	29, // 54: tapio.collector.v1.CollectorConfig.quality:type_name -> tapio.collector.v1.QualitySettings
	32, // 55: tapio.collector.v1.CollectorConfig.endpoints:type_name -> tapio.collector.v1.ServerEndpoint
	46, // 56: tapio.collector.v1.CollectorConfig.heartbeat_interval:type_name -> google.protobuf.Duration
	46, // 57: tapio.collector.v1.CollectorConfig.config_ttl:type_name -> google.protobuf.Duration
	43, // 58: tapio.collector.v1.RoutingConfig.type_routes:type_name -> tapio.collector.v1.RoutingConfig.TypeRoutesEntry
	3,  // 59: tapio.collector.v1.RoutingConfig.strategy:type_name -> tapio.collector.v1.LoadBalancingStrategy
	4,  // 60: tapio.collector.v1.ServerEndpoint.health:type_name -> tapio.collector.v1.HealthStatus
	44, // 61: tapio.collector.v1.HeartbeatRequest.timestamp:type_name -> google.protobuf.Timestamp
	16, // 62: tapio.collector.v1.HeartbeatRequest.status:type_name -> tapio.collector.v1.CollectorStatus
	44, // 63: tapio.collector.v1.HeartbeatResponse.timestamp:type_name -> google.protobuf.Timestamp
	17, // 64: tapio.collector.v1.HeartbeatResponse.server_status:type_name -> tapio.collector.v1.ServerStatus
	14, // 65: tapio.collector.v1.HeartbeatResponse.flow_control:type_name -> tapio.collector.v1.FlowControlDirective
	37, // 66: tapio.collector.v1.ServerInfoResponse.capabilities:type_name -> tapio.collector.v1.ServerCapabilities
	0,  // 67: tapio.collector.v1.ServerInfoResponse.supported_compression:type_name -> tapio.collector.v1.CompressionType
	38, // 68: tapio.collector.v1.ServerInfoResponse.rate_limits:type_name -> tapio.collector.v1.RateLimitInfo
	46, // 69: tapio.collector.v1.RateLimitInfo.window:type_name -> google.protobuf.Duration
	32, // 70: tapio.collector.v1.RegionInfo.endpoints:type_name -> tapio.collector.v1.ServerEndpoint
	5,  // 71: tapio.collector.v1.ErrorResponse.code:type_name -> tapio.collector.v1.ErrorCode
	44, // 72: tapio.collector.v1.ErrorResponse.timestamp:type_name -> google.protobuf.Timestamp
	46, // 73: tapio.collector.v1.ErrorResponse.retry_after:type_name -> google.protobuf.Duration
	6,  // 74: tapio.collector.v1.CollectorService.StreamEvents:input_type -> tapio.collector.v1.StreamRequest
	23, // 75: tapio.collector.v1.CollectorService.SendEventBatch:input_type -> tapio.collector.v1.EventBatchRequest
	25, // 76: tapio.collector.v1.CollectorService.RegisterCollector:input_type -> tapio.collector.v1.CollectorRegistration
	33, // 77: tapio.collector.v1.CollectorService.Heartbeat:input_type -> tapio.collector.v1.HeartbeatRequest
	35, // 78: tapio.collector.v1.CollectorService.GetServerInfo:input_type -> tapio.collector.v1.ServerInfoRequest
	7,  // 79: tapio.collector.v1.CollectorService.StreamEvents:output_type -> tapio.collector.v1.StreamResponse
	24, // 80: tapio.collector.v1.CollectorService.SendEventBatch:output_type -> tapio.collector.v1.EventBatchResponse
	30, // 81: tapio.collector.v1.CollectorService.RegisterCollector:output_type -> tapio.collector.v1.CollectorConfig
	34, // 82: tapio.collector.v1.CollectorService.Heartbeat:output_type -> tapio.collector.v1.HeartbeatResponse
	36, // 83: tapio.collector.v1.CollectorService.GetServerInfo:output_type -> tapio.collector.v1.ServerInfoResponse
	79, // [79:84] is the sub-list for method output_type
	74, // [74:79] is the sub-list for method input_type
	74, // [74:74] is the sub-list for extension type_name
	74, // [74:74] is the sub-list for extension extendee
	0,  // [0:74] is the sub-list for field type_name
}

func init() { file_proto_collector_proto_init() }
func file_proto_collector_proto_init() {
	if File_proto_collector_proto != nil {
		return
	}
	file_proto_collector_proto_msgTypes[0].OneofWrappers = []any{
		(*StreamRequest_Events)(nil),
		(*StreamRequest_FlowControl)(nil),
		(*StreamRequest_Status)(nil),
		(*StreamRequest_Ack)(nil),
	}
	file_proto_collector_proto_msgTypes[1].OneofWrappers = []any{
		(*StreamResponse_EventAck)(nil),
		(*StreamResponse_FlowControl)(nil),
		(*StreamResponse_ServerStatus)(nil),
		(*StreamResponse_Error)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_collector_proto_rawDesc), len(file_proto_collector_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   38,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_proto_collector_proto_goTypes,
		DependencyIndexes: file_proto_collector_proto_depIdxs,
		EnumInfos:         file_proto_collector_proto_enumTypes,
		MessageInfos:      file_proto_collector_proto_msgTypes,
	}.Build()
	File_proto_collector_proto = out.File
	file_proto_collector_proto_goTypes = nil
	file_proto_collector_proto_depIdxs = nil
}
