package k8s

import (
	"context"
	"encoding/binary"
	"fmt"
	"net"
	"sync"
	"time"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"github.com/yairfalse/tapio/pkg/collectors"
)

// K8sEventType represents different K8s-related syscall events
type K8sEventType uint32

const (
	EventK8sContainerCreate K8sEventType = 10
	EventK8sContainerDelete K8sEventType = 11
	EventK8sNetnsCreate     K8sEventType = 12
	EventK8sNetnsDelete     K8sEventType = 13
	EventK8sCgroupCreate    K8sEventType = 14
	EventK8sCgroupDelete    K8sEventType = 15
	EventK8sExecInPod       K8sEventType = 16
	EventK8sVolumeMount     K8sEventType = 17
	EventK8sVolumeUmount    K8sEventType = 18
	EventK8sImagePull       K8sEventType = 19
	EventK8sNetworkSetup    K8sEventType = 20
	EventK8sPodSandbox      K8sEventType = 21
	EventK8sDnsQuery        K8sEventType = 22
	EventK8sServiceConnect  K8sEventType = 23
)

// K8sEvent represents an eBPF event from K8s operations
type K8sEvent struct {
	Timestamp    uint64
	PID          uint32
	TID          uint32
	CgroupID     uint64
	NamespacePID uint32
	EventType    uint32
	CPU          uint32
	Comm         [16]byte
	ContainerID  [64]byte
	PodUID       [64]byte
	Namespace    [64]byte
	NetnsIno     uint32
	MntnsIno     uint32
	PidnsIno     uint32

	// Union data - we'll parse based on EventType
	Data [512]byte
}

// MountData represents mount operation details
type MountData struct {
	Source [128]byte
	Target [128]byte
	FSType [32]byte
	Flags  uint64
}

// NetworkData represents network operation details
type NetworkData struct {
	SAddr  uint32
	DAddr  uint32
	SPort  uint16
	DPort  uint16
	Family uint16
}

// FileData represents file operation details
type FileData struct {
	Filename [256]byte
	Flags    uint64
	Mode     uint64
}

// ExecData represents exec operation details
type ExecData struct {
	Filename [256]byte
	Argv0    [64]byte
}

// K8sPodInfo tracks pod information for correlation
type K8sPodInfo struct {
	PodUID    [64]byte
	Namespace [64]byte
	PodName   [128]byte
	CreatedAt uint64
}

// K8sEBPFCollector handles eBPF-based K8s syscall monitoring
type K8sEBPFCollector struct {
	mu     sync.RWMutex
	objs   *ebpfObjects
	links  []link.Link
	reader *ringbuf.Reader
	pods   map[uint64]*K8sPodInfo // cgroup_id -> pod info
	events chan K8sSyscallEvent
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup
}

// K8sSyscallEvent represents a processed K8s syscall event
type K8sSyscallEvent struct {
	Timestamp   time.Time
	PID         uint32
	TID         uint32
	CPU         uint32
	Command     string
	ContainerID string
	PodUID      string
	Namespace   string
	EventType   K8sEventType
	Details     interface{} // Type depends on EventType
}

// ebpfObjects will be generated by bpf2go
type ebpfObjects struct {
	K8sEvents *ebpf.Map
	K8sPods   *ebpf.Map
	Programs  struct {
		TracePodSandboxCreate *ebpf.Program
		TraceVolumeMount      *ebpf.Program
		TraceExecInPod        *ebpf.Program
		TraceImageOperations  *ebpf.Program
		TraceServiceConnect   *ebpf.Program
		TraceCgroupCreate     *ebpf.Program
		TraceDnsQuery         *ebpf.Program
	}
}

func (o *ebpfObjects) Close() error {
	// TODO: Implement proper cleanup when objects are generated
	return nil
}

// NewK8sEBPFCollector creates a new K8s eBPF collector
func NewK8sEBPFCollector() (*K8sEBPFCollector, error) {
	// Only supported on Linux
	if err := checkLinuxSupport(); err != nil {
		return nil, err
	}

	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock: %w", err)
	}

	return &K8sEBPFCollector{
		pods:   make(map[uint64]*K8sPodInfo),
		events: make(chan K8sSyscallEvent, 1000),
	}, nil
}

// Start begins eBPF collection
func (c *K8sEBPFCollector) Start(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.ctx, c.cancel = context.WithCancel(ctx)

	// Load eBPF objects (this would be generated by bpf2go)
	// For now, we'll need to implement the loading separately

	// Start event processing
	c.wg.Add(1)
	go c.processEvents()

	return nil
}

// Stop halts eBPF collection
func (c *K8sEBPFCollector) Stop() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.cancel != nil {
		c.cancel()
	}

	// Close links
	for _, l := range c.links {
		if err := l.Close(); err != nil {
			// Log error but continue closing other resources
			fmt.Printf("failed to close link: %v\n", err)
		}
	}

	// Close reader
	if c.reader != nil {
		if err := c.reader.Close(); err != nil {
			fmt.Printf("failed to close reader: %v\n", err)
		}
	}

	// Close eBPF objects
	if c.objs != nil {
		if err := c.objs.Close(); err != nil {
			fmt.Printf("failed to close eBPF objects: %v\n", err)
		}
	}

	c.wg.Wait()
	close(c.events)

	return nil
}

// Events returns the event channel
func (c *K8sEBPFCollector) Events() <-chan K8sSyscallEvent {
	return c.events
}

// UpdatePodInfo updates the pod tracking map
func (c *K8sEBPFCollector) UpdatePodInfo(cgroupID uint64, podUID, namespace, podName string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	info := &K8sPodInfo{
		CreatedAt: uint64(time.Now().UnixNano()),
	}
	copy(info.PodUID[:], podUID)
	copy(info.Namespace[:], namespace)
	copy(info.PodName[:], podName)

	c.pods[cgroupID] = info

	// Update eBPF map if available
	if c.objs != nil && c.objs.K8sPods != nil {
		return c.objs.K8sPods.Put(cgroupID, info)
	}

	return nil
}

// processEvents reads events from the ring buffer
func (c *K8sEBPFCollector) processEvents() {
	defer c.wg.Done()

	for {
		record, err := c.reader.Read()
		if err != nil {
			if err == ringbuf.ErrClosed {
				return
			}
			continue
		}

		// Parse the raw event
		if len(record.RawSample) < int(unsafe.Sizeof(K8sEvent{})) {
			continue
		}

		event := (*K8sEvent)(unsafe.Pointer(&record.RawSample[0]))
		processed := c.processK8sEvent(event)

		select {
		case c.events <- processed:
		case <-c.ctx.Done():
			return
		}
	}
}

// processK8sEvent converts raw eBPF event to processed event
func (c *K8sEBPFCollector) processK8sEvent(raw *K8sEvent) K8sSyscallEvent {
	event := K8sSyscallEvent{
		Timestamp:   time.Unix(0, int64(raw.Timestamp)),
		PID:         raw.PID,
		TID:         raw.TID,
		CPU:         raw.CPU,
		Command:     string(raw.Comm[:cStringLen(raw.Comm[:])]),
		ContainerID: string(raw.ContainerID[:cStringLen(raw.ContainerID[:])]),
		PodUID:      string(raw.PodUID[:cStringLen(raw.PodUID[:])]),
		Namespace:   string(raw.Namespace[:cStringLen(raw.Namespace[:])]),
		EventType:   K8sEventType(raw.EventType),
	}

	// Parse event-specific data
	switch event.EventType {
	case EventK8sVolumeMount:
		var mount MountData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&mount)), unsafe.Sizeof(mount)), raw.Data[:])
		event.Details = struct {
			Source string
			Target string
			FSType string
			Flags  uint64
		}{
			Source: string(mount.Source[:cStringLen(mount.Source[:])]),
			Target: string(mount.Target[:cStringLen(mount.Target[:])]),
			FSType: string(mount.FSType[:cStringLen(mount.FSType[:])]),
			Flags:  mount.Flags,
		}

	case EventK8sServiceConnect, EventK8sDnsQuery:
		var netData NetworkData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&netData)), unsafe.Sizeof(netData)), raw.Data[:])
		event.Details = struct {
			SourceIP   string
			DestIP     string
			SourcePort uint16
			DestPort   uint16
			Family     uint16
		}{
			SourceIP:   intToIP(netData.SAddr),
			DestIP:     intToIP(netData.DAddr),
			SourcePort: netData.SPort,
			DestPort:   netData.DPort,
			Family:     netData.Family,
		}

	case EventK8sExecInPod:
		var exec ExecData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&exec)), unsafe.Sizeof(exec)), raw.Data[:])
		event.Details = struct {
			Filename string
			Argv0    string
		}{
			Filename: string(exec.Filename[:cStringLen(exec.Filename[:])]),
			Argv0:    string(exec.Argv0[:cStringLen(exec.Argv0[:])]),
		}

	case EventK8sImagePull:
		var file FileData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&file)), unsafe.Sizeof(file)), raw.Data[:])
		event.Details = struct {
			Filename string
			Flags    uint64
			Mode     uint64
		}{
			Filename: string(file.Filename[:cStringLen(file.Filename[:])]),
			Flags:    file.Flags,
			Mode:     file.Mode,
		}
	}

	return event
}

// Helper functions
func cStringLen(b []byte) int {
	for i := 0; i < len(b); i++ {
		if b[i] == 0 {
			return i
		}
	}
	return len(b)
}

func intToIP(ip uint32) string {
	return net.IPv4(byte(ip), byte(ip>>8), byte(ip>>16), byte(ip>>24)).String()
}

// ConvertToRawEvent converts K8s syscall event to collector RawEvent
func ConvertK8sSyscallEvent(event K8sSyscallEvent) collectors.RawEvent {
	metadata := map[string]string{
		"event_type":   fmt.Sprintf("%d", event.EventType),
		"pid":          fmt.Sprintf("%d", event.PID),
		"tid":          fmt.Sprintf("%d", event.TID),
		"cpu":          fmt.Sprintf("%d", event.CPU),
		"command":      event.Command,
		"container_id": event.ContainerID,
		"pod_uid":      event.PodUID,
		"namespace":    event.Namespace,
	}

	// Add event-specific metadata
	switch details := event.Details.(type) {
	case struct {
		Source string
		Target string
		FSType string
		Flags  uint64
	}:
		metadata["mount_source"] = details.Source
		metadata["mount_target"] = details.Target
		metadata["mount_fstype"] = details.FSType
		metadata["mount_flags"] = fmt.Sprintf("%d", details.Flags)

	case struct {
		SourceIP   string
		DestIP     string
		SourcePort uint16
		DestPort   uint16
		Family     uint16
	}:
		metadata["src_ip"] = details.SourceIP
		metadata["dst_ip"] = details.DestIP
		metadata["src_port"] = fmt.Sprintf("%d", details.SourcePort)
		metadata["dst_port"] = fmt.Sprintf("%d", details.DestPort)

	case struct {
		Filename string
		Argv0    string
	}:
		metadata["exec_filename"] = details.Filename
		metadata["exec_argv0"] = details.Argv0

	case struct {
		Filename string
		Flags    uint64
		Mode     uint64
	}:
		metadata["file_path"] = details.Filename
		metadata["file_flags"] = fmt.Sprintf("%d", details.Flags)
		metadata["file_mode"] = fmt.Sprintf("%d", details.Mode)
	}

	// Create raw event
	rawData := make([]byte, 8)
	binary.LittleEndian.PutUint64(rawData, uint64(event.EventType))

	return collectors.RawEvent{
		Timestamp: event.Timestamp,
		Type:      "k8s_syscall",
		Data:      rawData,
		Metadata:  metadata,
	}
}

// checkLinuxSupport checks if we're running on Linux
func checkLinuxSupport() error {
	// This will be compiled on all platforms but only succeed on Linux
	// The actual eBPF operations will fail on non-Linux
	return nil
}
