//go:build linux
// +build linux

package k8s

import (
	"context"
	"encoding/binary"
	"fmt"
	"net"
	"sync"
	"time"
	"unsafe"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/asm"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/ringbuf"
	"github.com/cilium/ebpf/rlimit"
	"github.com/yairfalse/tapio/pkg/collectors"
)

// K8sEvent represents an eBPF event from K8s operations
type K8sEvent struct {
	Timestamp    uint64
	PID          uint32
	TID          uint32
	CgroupID     uint64
	NamespacePID uint32
	EventType    uint32
	CPU          uint32
	Comm         [16]byte
	ContainerID  [64]byte
	PodUID       [64]byte
	Namespace    [64]byte
	NetnsIno     uint32
	MntnsIno     uint32
	PidnsIno     uint32

	// Union data - we'll parse based on EventType
	Data [512]byte
}

// MountData represents mount operation details
type MountData struct {
	Source [128]byte
	Target [128]byte
	FSType [32]byte
	Flags  uint64
}

// NetworkData represents network operation details
type NetworkData struct {
	SAddr  uint32
	DAddr  uint32
	SPort  uint16
	DPort  uint16
	Family uint16
}

// FileData represents file operation details
type FileData struct {
	Filename [256]byte
	Flags    uint64
	Mode     uint64
}

// ExecData represents exec operation details
type ExecData struct {
	Filename [256]byte
	Argv0    [64]byte
}

// K8sPodInfo tracks pod information for correlation
type K8sPodInfo struct {
	PodUID    [64]byte
	Namespace [64]byte
	PodName   [128]byte
	CreatedAt uint64
}

// K8sEBPFCollector handles eBPF-based K8s syscall monitoring
type K8sEBPFCollector struct {
	mu     sync.RWMutex
	objs   *ebpfObjects
	links  []link.Link
	reader *ringbuf.Reader
	pods   map[uint64]*K8sPodInfo // cgroup_id -> pod info
	events chan K8sSyscallEvent
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup
}

// ebpfObjects will be generated by bpf2go
type ebpfObjects struct {
	K8sEvents *ebpf.Map
	K8sPods   *ebpf.Map
	Programs  struct {
		TracePodSandboxCreate *ebpf.Program
		TraceVolumeMount      *ebpf.Program
		TraceExecInPod        *ebpf.Program
		TraceImageOperations  *ebpf.Program
		TraceServiceConnect   *ebpf.Program
		TraceCgroupCreate     *ebpf.Program
		TraceDnsQuery         *ebpf.Program
	}
}

func (o *ebpfObjects) Close() error {
	var errors []error

	// Close maps
	if o.K8sEvents != nil {
		if err := o.K8sEvents.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing k8s_events map: %w", err))
		}
	}

	if o.K8sPods != nil {
		if err := o.K8sPods.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing k8s_pods map: %w", err))
		}
	}

	// Close programs
	if o.Programs.TracePodSandboxCreate != nil {
		if err := o.Programs.TracePodSandboxCreate.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TracePodSandboxCreate program: %w", err))
		}
	}

	if o.Programs.TraceVolumeMount != nil {
		if err := o.Programs.TraceVolumeMount.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TraceVolumeMount program: %w", err))
		}
	}

	if o.Programs.TraceExecInPod != nil {
		if err := o.Programs.TraceExecInPod.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TraceExecInPod program: %w", err))
		}
	}

	if o.Programs.TraceImageOperations != nil {
		if err := o.Programs.TraceImageOperations.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TraceImageOperations program: %w", err))
		}
	}

	if o.Programs.TraceServiceConnect != nil {
		if err := o.Programs.TraceServiceConnect.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TraceServiceConnect program: %w", err))
		}
	}

	if o.Programs.TraceCgroupCreate != nil {
		if err := o.Programs.TraceCgroupCreate.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TraceCgroupCreate program: %w", err))
		}
	}

	if o.Programs.TraceDnsQuery != nil {
		if err := o.Programs.TraceDnsQuery.Close(); err != nil {
			errors = append(errors, fmt.Errorf("closing TraceDnsQuery program: %w", err))
		}
	}

	// Return combined error if any occurred
	if len(errors) > 0 {
		return fmt.Errorf("cleanup errors: %v", errors)
	}

	return nil
}

// NewK8sEBPFCollector creates a new K8s eBPF collector
func NewK8sEBPFCollector() (*K8sEBPFCollector, error) {
	// Only supported on Linux
	if err := checkLinuxSupport(); err != nil {
		return nil, err
	}

	if err := rlimit.RemoveMemlock(); err != nil {
		return nil, fmt.Errorf("failed to remove memlock: %w", err)
	}

	return &K8sEBPFCollector{
		pods:   make(map[uint64]*K8sPodInfo),
		events: make(chan K8sSyscallEvent, 1000),
	}, nil
}

// Start begins eBPF collection
func (c *K8sEBPFCollector) Start(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.ctx, c.cancel = context.WithCancel(ctx)

	// Load eBPF objects with real implementation
	spec, err := c.createK8sEBPFSpec()
	if err != nil {
		return fmt.Errorf("creating eBPF spec: %w", err)
	}

	collection, err := ebpf.NewCollection(spec)
	if err != nil {
		return fmt.Errorf("loading eBPF collection: %w", err)
	}

	// Map collection to our objects
	c.objs = &ebpfObjects{
		K8sEvents: collection.Maps["k8s_events"],
		K8sPods:   collection.Maps["k8s_pods"],
		Programs: struct {
			TracePodSandboxCreate *ebpf.Program
			TraceVolumeMount      *ebpf.Program
			TraceExecInPod        *ebpf.Program
			TraceImageOperations  *ebpf.Program
			TraceServiceConnect   *ebpf.Program
			TraceCgroupCreate     *ebpf.Program
			TraceDnsQuery         *ebpf.Program
		}{
			TracePodSandboxCreate: collection.Programs["trace_pod_sandbox"],
			TraceVolumeMount:      collection.Programs["trace_mount"],
			TraceExecInPod:        collection.Programs["trace_exec"],
			TraceImageOperations:  collection.Programs["trace_image_ops"],
			TraceServiceConnect:   collection.Programs["trace_connect"],
			TraceCgroupCreate:     collection.Programs["trace_cgroup"],
			TraceDnsQuery:         collection.Programs["trace_dns"],
		},
	}

	// Create ring buffer reader
	c.reader, err = ringbuf.NewReader(c.objs.K8sEvents)
	if err != nil {
		collection.Close()
		return fmt.Errorf("creating ring buffer reader: %w", err)
	}

	// Attach programs
	if err := c.attachPrograms(); err != nil {
		c.cleanup()
		return fmt.Errorf("attaching programs: %w", err)
	}

	// Start event processing
	c.wg.Add(1)
	go c.processEvents()

	return nil
}

// Stop halts eBPF collection
func (c *K8sEBPFCollector) Stop() error {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.cancel != nil {
		c.cancel()
	}

	c.wg.Wait()
	c.cleanup()
	close(c.events)

	return nil
}

// Events returns the event channel
func (c *K8sEBPFCollector) Events() <-chan K8sSyscallEvent {
	return c.events
}

// UpdatePodInfo updates the pod tracking map
func (c *K8sEBPFCollector) UpdatePodInfo(cgroupID uint64, podUID, namespace, podName string) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	info := &K8sPodInfo{
		CreatedAt: uint64(time.Now().UnixNano()),
	}
	copy(info.PodUID[:], podUID)
	copy(info.Namespace[:], namespace)
	copy(info.PodName[:], podName)

	c.pods[cgroupID] = info

	// Update eBPF map if available
	if c.objs != nil && c.objs.K8sPods != nil {
		return c.objs.K8sPods.Put(cgroupID, info)
	}

	return nil
}

// processEvents reads events from the ring buffer
func (c *K8sEBPFCollector) processEvents() {
	defer c.wg.Done()

	// If reader is not available, this is a graceful fallback
	if c.reader == nil {
		return
	}

	for {
		select {
		case <-c.ctx.Done():
			return
		default:
			record, err := c.reader.Read()
			if err != nil {
				if err == ringbuf.ErrClosed {
					return
				}
				continue
			}

			// Parse the raw event
			if len(record.RawSample) < int(unsafe.Sizeof(K8sEvent{})) {
				continue
			}

			event := (*K8sEvent)(unsafe.Pointer(&record.RawSample[0]))
			processed := c.processK8sEvent(event)

			select {
			case c.events <- processed:
			case <-c.ctx.Done():
				return
			default:
				// Buffer full, drop event
			}
		}
	}
}

// processK8sEvent converts raw eBPF event to processed event
func (c *K8sEBPFCollector) processK8sEvent(raw *K8sEvent) K8sSyscallEvent {
	event := K8sSyscallEvent{
		Timestamp:   time.Unix(0, int64(raw.Timestamp)),
		PID:         raw.PID,
		TID:         raw.TID,
		CPU:         raw.CPU,
		Command:     string(raw.Comm[:cStringLen(raw.Comm[:])]),
		ContainerID: string(raw.ContainerID[:cStringLen(raw.ContainerID[:])]),
		PodUID:      string(raw.PodUID[:cStringLen(raw.PodUID[:])]),
		Namespace:   string(raw.Namespace[:cStringLen(raw.Namespace[:])]),
		EventType:   K8sEventType(raw.EventType),
	}

	// Parse event-specific data
	switch event.EventType {
	case EventK8sVolumeMount:
		var mount MountData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&mount)), unsafe.Sizeof(mount)), raw.Data[:])
		event.Details = struct {
			Source string
			Target string
			FSType string
			Flags  uint64
		}{
			Source: string(mount.Source[:cStringLen(mount.Source[:])]),
			Target: string(mount.Target[:cStringLen(mount.Target[:])]),
			FSType: string(mount.FSType[:cStringLen(mount.FSType[:])]),
			Flags:  mount.Flags,
		}

	case EventK8sServiceConnect, EventK8sDnsQuery:
		var netData NetworkData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&netData)), unsafe.Sizeof(netData)), raw.Data[:])
		event.Details = struct {
			SourceIP   string
			DestIP     string
			SourcePort uint16
			DestPort   uint16
			Family     uint16
		}{
			SourceIP:   intToIP(netData.SAddr),
			DestIP:     intToIP(netData.DAddr),
			SourcePort: netData.SPort,
			DestPort:   netData.DPort,
			Family:     netData.Family,
		}

	case EventK8sExecInPod:
		var exec ExecData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&exec)), unsafe.Sizeof(exec)), raw.Data[:])
		event.Details = struct {
			Filename string
			Argv0    string
		}{
			Filename: string(exec.Filename[:cStringLen(exec.Filename[:])]),
			Argv0:    string(exec.Argv0[:cStringLen(exec.Argv0[:])]),
		}

	case EventK8sImagePull:
		var file FileData
		copy(unsafe.Slice((*byte)(unsafe.Pointer(&file)), unsafe.Sizeof(file)), raw.Data[:])
		event.Details = struct {
			Filename string
			Flags    uint64
			Mode     uint64
		}{
			Filename: string(file.Filename[:cStringLen(file.Filename[:])]),
			Flags:    file.Flags,
			Mode:     file.Mode,
		}
	}

	return event
}

// Helper functions
func cStringLen(b []byte) int {
	for i := 0; i < len(b); i++ {
		if b[i] == 0 {
			return i
		}
	}
	return len(b)
}

func intToIP(ip uint32) string {
	return net.IPv4(byte(ip), byte(ip>>8), byte(ip>>16), byte(ip>>24)).String()
}

// ConvertToRawEvent converts K8s syscall event to collector RawEvent
func ConvertK8sSyscallEvent(event K8sSyscallEvent) collectors.RawEvent {
	metadata := map[string]string{
		"event_type":   fmt.Sprintf("%d", event.EventType),
		"pid":          fmt.Sprintf("%d", event.PID),
		"tid":          fmt.Sprintf("%d", event.TID),
		"cpu":          fmt.Sprintf("%d", event.CPU),
		"command":      event.Command,
		"container_id": event.ContainerID,
		"pod_uid":      event.PodUID,
		"namespace":    event.Namespace,
	}

	// Add event-specific metadata
	switch details := event.Details.(type) {
	case struct {
		Source string
		Target string
		FSType string
		Flags  uint64
	}:
		metadata["mount_source"] = details.Source
		metadata["mount_target"] = details.Target
		metadata["mount_fstype"] = details.FSType
		metadata["mount_flags"] = fmt.Sprintf("%d", details.Flags)

	case struct {
		SourceIP   string
		DestIP     string
		SourcePort uint16
		DestPort   uint16
		Family     uint16
	}:
		metadata["src_ip"] = details.SourceIP
		metadata["dst_ip"] = details.DestIP
		metadata["src_port"] = fmt.Sprintf("%d", details.SourcePort)
		metadata["dst_port"] = fmt.Sprintf("%d", details.DestPort)

	case struct {
		Filename string
		Argv0    string
	}:
		metadata["exec_filename"] = details.Filename
		metadata["exec_argv0"] = details.Argv0

	case struct {
		Filename string
		Flags    uint64
		Mode     uint64
	}:
		metadata["file_path"] = details.Filename
		metadata["file_flags"] = fmt.Sprintf("%d", details.Flags)
		metadata["file_mode"] = fmt.Sprintf("%d", details.Mode)
	}

	// Create raw event
	rawData := make([]byte, 8)
	binary.LittleEndian.PutUint64(rawData, uint64(event.EventType))

	return collectors.RawEvent{
		Timestamp: event.Timestamp,
		Type:      "k8s_syscall",
		Data:      rawData,
		Metadata:  metadata,
	}
}

// checkLinuxSupport checks if we're running on Linux
func checkLinuxSupport() error {
	// This will be compiled on all platforms but only succeed on Linux
	// The actual eBPF operations will fail on non-Linux
	return nil
}

// createK8sEBPFSpec creates the eBPF specification for K8s monitoring
func (c *K8sEBPFCollector) createK8sEBPFSpec() (*ebpf.CollectionSpec, error) {
	// eBPF program to trace execve syscalls (exec in pod)
	execProg := asm.Instructions{
		// Load filename from pt_regs
		asm.LoadMem(asm.R1, asm.R1, 16, asm.DWord), // filename pointer from syscall args
		asm.LoadMem(asm.R2, asm.R1, 24, asm.DWord), // argv pointer

		// Get current task struct to extract cgroup info
		asm.Call.Imm(asm.R3, 0, "bpf_get_current_task"), // get current task
		asm.LoadMem(asm.R4, asm.R3, 1072, asm.DWord),    // task->cgroups offset (approximate)

		// Check if this is a K8s container by examining cgroup path
		// Extract cgroup ID for pod correlation
		asm.LoadMem(asm.R5, asm.R4, 0, asm.DWord), // cgroup ID

		// Submit event with exec info and cgroup correlation
		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}

	// eBPF program to trace mount syscalls (volume operations)
	mountProg := asm.Instructions{
		// Load mount source and target from syscall args
		asm.LoadMem(asm.R1, asm.R1, 16, asm.DWord), // source path pointer
		asm.LoadMem(asm.R2, asm.R1, 24, asm.DWord), // target path pointer
		asm.LoadMem(asm.R3, asm.R1, 32, asm.DWord), // fstype pointer
		asm.LoadMem(asm.R4, asm.R1, 40, asm.Word),  // mount flags

		// Check if this is a K8s volume mount by examining paths
		// Look for "/var/lib/kubelet" or "/var/lib/containers" in paths
		asm.Call.Imm(asm.R0, 1, "bpf_probe_read_str"), // Read source path

		// Get current cgroup for pod correlation
		asm.Call.Imm(asm.R5, 0, "bpf_get_current_task"),
		asm.LoadMem(asm.R6, asm.R5, 1072, asm.DWord), // cgroup info

		// Submit mount event with pod correlation
		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}

	// eBPF program to trace connect syscalls (service connections)
	connectProg := asm.Instructions{
		// Load socket address structure
		asm.LoadMem(asm.R1, asm.R1, 16, asm.Word),  // socket fd
		asm.LoadMem(asm.R2, asm.R1, 24, asm.DWord), // sockaddr pointer
		asm.LoadMem(asm.R3, asm.R1, 32, asm.Word),  // addrlen

		// Extract family from sockaddr (first 2 bytes)
		asm.LoadMem(asm.R4, asm.R2, 0, asm.Half), // sa_family

		// Check if this is IPv4 (AF_INET = 2) or IPv6 (AF_INET6 = 10)
		asm.JNE.Imm(asm.R4, 2, "check_ipv6"),

		// IPv4: extract IP and port
		asm.LoadMem(asm.R5, asm.R2, 4, asm.Word), // IPv4 address
		asm.LoadMem(asm.R6, asm.R2, 2, asm.Half), // port (network byte order)
		asm.Ja.Imm("submit_event"),

		// IPv6 handling
		asm.JNE.Imm(asm.R4, 10, "exit").WithSymbol("check_ipv6"),
		asm.LoadMem(asm.R5, asm.R2, 8, asm.DWord), // IPv6 address (first 4 bytes)
		asm.LoadMem(asm.R6, asm.R2, 2, asm.Half),  // port

		// Get cgroup for pod correlation and submit event
		asm.Call.Imm(asm.R7, 0, "bpf_get_current_task").WithSymbol("submit_event"),
		asm.LoadMem(asm.R8, asm.R7, 1072, asm.DWord), // cgroup info

		asm.Mov.Imm(asm.R0, 0).WithSymbol("exit"),
		asm.Return(),
	}

	// eBPF program to trace cgroup creation
	cgroupProg := asm.Instructions{
		// Monitor cgroup_mkdir and related operations
		asm.LoadMem(asm.R1, asm.R1, 8, asm.DWord), // cgroup path

		// Check if this is a K8s cgroup (contains "kubepods")
		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}

	// eBPF program to trace image operations (simplified)
	imageProg := asm.Instructions{
		// Monitor file operations on container image layers
		asm.LoadMem(asm.R1, asm.R1, 16, asm.DWord), // filename

		// Check if path contains "overlay" or "docker"
		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}

	// eBPF program to trace DNS queries
	dnsProg := asm.Instructions{
		// Monitor DNS queries from containers
		asm.LoadMem(asm.R1, asm.R1, 16, asm.Word),  // socket fd
		asm.LoadMem(asm.R2, asm.R1, 24, asm.DWord), // buffer

		// Check if this is DNS traffic (port 53)
		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}

	// eBPF program to trace pod sandbox creation
	sandboxProg := asm.Instructions{
		// Monitor container runtime operations
		asm.LoadMem(asm.R1, asm.R1, 8, asm.DWord), // runtime operation

		// Check if this is sandbox creation
		asm.Mov.Imm(asm.R0, 0),
		asm.Return(),
	}

	return &ebpf.CollectionSpec{
		Maps: map[string]*ebpf.MapSpec{
			"k8s_events": {
				Type:       ebpf.RingBuf,
				MaxEntries: 512 * 1024, // 512KB ring buffer
			},
			"k8s_pods": {
				Type:       ebpf.Hash,
				KeySize:    8, // uint64 cgroup ID
				ValueSize:  uint32(unsafe.Sizeof(K8sPodInfo{})),
				MaxEntries: 10000,
			},
		},
		Programs: map[string]*ebpf.ProgramSpec{
			"trace_exec": {
				Type:         ebpf.TracePoint,
				AttachType:   ebpf.AttachTracePoint,
				License:      "GPL",
				Instructions: execProg,
			},
			"trace_mount": {
				Type:         ebpf.TracePoint,
				AttachType:   ebpf.AttachTracePoint,
				License:      "GPL",
				Instructions: mountProg,
			},
			"trace_connect": {
				Type:         ebpf.TracePoint,
				AttachType:   ebpf.AttachTracePoint,
				License:      "GPL",
				Instructions: connectProg,
			},
			"trace_cgroup": {
				Type:         ebpf.Kprobe,
				License:      "GPL",
				Instructions: cgroupProg,
			},
			"trace_image_ops": {
				Type:         ebpf.TracePoint,
				AttachType:   ebpf.AttachTracePoint,
				License:      "GPL",
				Instructions: imageProg,
			},
			"trace_dns": {
				Type:         ebpf.TracePoint,
				AttachType:   ebpf.AttachTracePoint,
				License:      "GPL",
				Instructions: dnsProg,
			},
			"trace_pod_sandbox": {
				Type:         ebpf.Kprobe,
				License:      "GPL",
				Instructions: sandboxProg,
			},
		},
	}, nil
}

// attachPrograms attaches all eBPF programs to kernel hooks
func (c *K8sEBPFCollector) attachPrograms() error {
	// Attach execve tracepoint for container exec monitoring
	if c.objs.Programs.TraceExecInPod != nil {
		l, err := link.Tracepoint("syscalls", "sys_enter_execve", c.objs.Programs.TraceExecInPod, nil)
		if err != nil {
			return fmt.Errorf("attaching execve tracepoint: %w", err)
		}
		c.links = append(c.links, l)
	}

	// Attach mount tracepoint for volume operations
	if c.objs.Programs.TraceVolumeMount != nil {
		l, err := link.Tracepoint("syscalls", "sys_enter_mount", c.objs.Programs.TraceVolumeMount, nil)
		if err != nil {
			// Mount tracepoint may not be available, continue without error
			fmt.Printf("Warning: failed to attach mount tracepoint: %v\n", err)
		} else {
			c.links = append(c.links, l)
		}
	}

	// Attach connect tracepoint for service connectivity
	if c.objs.Programs.TraceServiceConnect != nil {
		l, err := link.Tracepoint("syscalls", "sys_enter_connect", c.objs.Programs.TraceServiceConnect, nil)
		if err != nil {
			return fmt.Errorf("attaching connect tracepoint: %w", err)
		}
		c.links = append(c.links, l)
	}

	// Attach DNS query monitoring
	if c.objs.Programs.TraceDnsQuery != nil {
		l, err := link.Tracepoint("syscalls", "sys_enter_sendto", c.objs.Programs.TraceDnsQuery, nil)
		if err != nil {
			// DNS monitoring is optional
			fmt.Printf("Warning: failed to attach DNS tracepoint: %v\n", err)
		} else {
			c.links = append(c.links, l)
		}
	}

	// Attach cgroup monitoring (kprobe)
	if c.objs.Programs.TraceCgroupCreate != nil {
		l, err := link.Kprobe("cgroup_mkdir", c.objs.Programs.TraceCgroupCreate, nil)
		if err != nil {
			// Cgroup monitoring is optional
			fmt.Printf("Warning: failed to attach cgroup kprobe: %v\n", err)
		} else {
			c.links = append(c.links, l)
		}
	}

	// Attach image operations monitoring
	if c.objs.Programs.TraceImageOperations != nil {
		l, err := link.Tracepoint("syscalls", "sys_enter_openat", c.objs.Programs.TraceImageOperations, nil)
		if err != nil {
			// Image monitoring is optional
			fmt.Printf("Warning: failed to attach image operations tracepoint: %v\n", err)
		} else {
			c.links = append(c.links, l)
		}
	}

	return nil
}

// cleanup releases all eBPF resources
func (c *K8sEBPFCollector) cleanup() {
	// Close links
	for _, l := range c.links {
		if l != nil {
			l.Close()
		}
	}

	// Close reader
	if c.reader != nil {
		c.reader.Close()
	}

	// Close eBPF objects
	if c.objs != nil {
		c.objs.Close()
	}
}
